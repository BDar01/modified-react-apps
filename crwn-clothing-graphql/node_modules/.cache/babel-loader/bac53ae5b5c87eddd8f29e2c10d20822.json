{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport { isEnumType, isInputObjectType, isInputType, isInterfaceType, isNamedType, isNonNullType, isObjectType, isOutputType, isRequiredArgument, isRequiredInputField, isUnionType } from './definition.mjs';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { assertSchema } from './schema.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(new GraphQLError(message, {\n      nodes: _nodes\n    }));\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n  schemaNode => {\n    var _schemaNode$operation;\n\n    return (\n      /* c8 ignore next */\n      (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []\n    );\n  }).find(operationNode => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive);\n\n    if (directive.locations.length === 0) {\n      context.reportError(`Directive @${directive.name} must include 1 or more locations.`, directive.astNode);\n    } // Ensure the arguments are valid.\n\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(`Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`, node.astNode);\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(`Expected GraphQL named type but got: ${inspect(type)}.`, type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [type.astNode, ...type.extensionASTNodes]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(`Type ${inspect(type)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [(_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find(arg => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [(_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n\n    } // Assert additional arguments must not be required.\n\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find(arg => arg.name === argName);\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [...getAllImplementsInterfaceNodes(iface, transitive), ...getAllImplementsInterfaceNodes(type, iface)]);\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);\n  } // Ensure the arguments are valid\n\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [getDeprecatedDirectiveNode(field.astNode), (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n\n    if (inputObj.isOneOf) {\n      validateOneOfInputObjectField(inputObj, field, context);\n    }\n  }\n}\n\nfunction validateOneOfInputObjectField(type, field, context) {\n  if (isNonNullType(field.type)) {\n    var _field$astNode4;\n\n    context.reportError(`OneOf input field ${type.name}.${field.name} must be nullable.`, (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0 ? void 0 : _field$astNode4.type);\n  }\n\n  if (field.defaultValue !== undefined) {\n    context.reportError(`OneOf input field ${type.name}.${field.name} cannot have a default value.`, field.astNode);\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map(fieldObj => fieldObj.name).join('.');\n          context.reportError(`Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`, cyclePath.map(fieldObj => fieldObj.astNode));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = type;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(typeNode => {\n    var _typeNode$interfaces;\n\n    return (\n      /* c8 ignore next */\n      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []\n    );\n  }).filter(ifaceNode => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = union;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(unionNode => {\n    var _unionNode$types;\n\n    return (\n      /* c8 ignore next */\n      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []\n    );\n  }).filter(typeNode => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(node => node.name.value === GraphQLDeprecatedDirective.name);\n}","map":{"version":3,"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/graphql/type/validate.mjs"],"names":["inspect","GraphQLError","OperationTypeNode","isEqualType","isTypeSubTypeOf","isEnumType","isInputObjectType","isInputType","isInterfaceType","isNamedType","isNonNullType","isObjectType","isOutputType","isRequiredArgument","isRequiredInputField","isUnionType","GraphQLDeprecatedDirective","isDirective","isIntrospectionType","assertSchema","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","constructor","_errors","reportError","nodes","_nodes","Array","isArray","filter","Boolean","push","queryType","getQueryType","astNode","_getOperationTypeNode","getOperationTypeNode","QUERY","mutationType","getMutationType","_getOperationTypeNode2","MUTATION","subscriptionType","getSubscriptionType","_getOperationTypeNode3","SUBSCRIPTION","operation","_flatMap$find","extensionASTNodes","flatMap","schemaNode","_schemaNode$operation","operationTypes","find","operationNode","type","directive","getDirectives","validateName","locations","name","arg","args","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","node","startsWith","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","Object","values","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","field","_field$astNode","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","create","iface","getInterfaces","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","ifaceField","fieldName","typeField","_ifaceField$astNode","_typeField$astNode","ifaceArg","typeArg","_ifaceArg$astNode","_typeArg$astNode","ifaceInterfaces","transitive","includes","union","memberTypes","getTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","enumValue","inputObj","_field$astNode2","_field$astNode3","isOneOf","validateOneOfInputObjectField","_field$astNode4","defaultValue","undefined","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","ofType","fieldType","cycleIndex","cyclePath","slice","pathStr","fieldObj","pop","typeNode","_typeNode$interfaces","interfaces","ifaceNode","value","typeName","unionNode","_unionNode$types","types","definitionNode","_definitionNode$direc","directives"],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInputType,\n  isInterfaceType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isOutputType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isUnionType,\n} from './definition.mjs';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { assertSchema } from './schema.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(\n      new GraphQLError(message, {\n        nodes: _nodes,\n      }),\n    );\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\n      `Query root type must be Object type, it cannot be ${inspect(\n        queryType,\n      )}.`,\n      (_getOperationTypeNode = getOperationTypeNode(\n        schema,\n        OperationTypeNode.QUERY,\n      )) !== null && _getOperationTypeNode !== void 0\n        ? _getOperationTypeNode\n        : queryType.astNode,\n    );\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError(\n      'Mutation root type must be Object type if provided, it cannot be ' +\n        `${inspect(mutationType)}.`,\n      (_getOperationTypeNode2 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.MUTATION,\n      )) !== null && _getOperationTypeNode2 !== void 0\n        ? _getOperationTypeNode2\n        : mutationType.astNode,\n    );\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError(\n      'Subscription root type must be Object type if provided, it cannot be ' +\n        `${inspect(subscriptionType)}.`,\n      (_getOperationTypeNode3 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.SUBSCRIPTION,\n      )) !== null && _getOperationTypeNode3 !== void 0\n        ? _getOperationTypeNode3\n        : subscriptionType.astNode,\n    );\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (schemaNode) => {\n        var _schemaNode$operation;\n\n        return (\n          /* c8 ignore next */\n          (_schemaNode$operation =\n            schemaNode === null || schemaNode === void 0\n              ? void 0\n              : schemaNode.operationTypes) !== null &&\n            _schemaNode$operation !== void 0\n            ? _schemaNode$operation\n            : []\n        );\n      },\n    )\n    .find((operationNode) => operationNode.operation === operation)) === null ||\n    _flatMap$find === void 0\n    ? void 0\n    : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\n        `Expected directive but got: ${inspect(directive)}.`,\n        directive === null || directive === void 0 ? void 0 : directive.astNode,\n      );\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive);\n\n    if (directive.locations.length === 0) {\n      context.reportError(\n        `Directive @${directive.name} must include 1 or more locations.`,\n        directive.astNode,\n      );\n    } // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\n          `The type of @${directive.name}(${arg.name}:) must be Input Type ` +\n            `but got: ${inspect(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(\n          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0\n              ? void 0\n              : _arg$astNode.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs =\n    createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${inspect(type)}.`,\n        type.astNode,\n      );\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\n        `The type of ${type.name}.${field.name} must be Output Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode = field.astNode) === null || _field$astNode === void 0\n          ? void 0\n          : _field$astNode.type,\n      );\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\n          `The type of ${type.name}.${field.name}(${argName}:) must be Input ` +\n            `Type but got: ${inspect(arg.type)}.`,\n          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0\n            ? void 0\n            : _arg$astNode2.type,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(\n          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0\n              ? void 0\n              : _arg$astNode3.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(\n        `Type ${inspect(type)} must only implement Interface types, ` +\n          `it cannot implement ${inspect(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type.name} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\n        `Type ${type.name} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` +\n          `is type ${inspect(typeField.type)}.`,\n        [\n          (_ifaceField$astNode = ifaceField.astNode) === null ||\n          _ifaceField$astNode === void 0\n            ? void 0\n            : _ifaceField$astNode.type,\n          (_typeField$astNode = typeField.astNode) === null ||\n          _typeField$astNode === void 0\n            ? void 0\n            : _typeField$astNode.type,\n        ],\n      );\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${inspect(ifaceArg.type)} but ` +\n            `${type.name}.${fieldName}(${argName}:) is type ` +\n            `${inspect(typeArg.type)}.`,\n          [\n            (_ifaceArg$astNode = ifaceArg.astNode) === null ||\n            _ifaceArg$astNode === void 0\n              ? void 0\n              : _ifaceArg$astNode.type,\n            (_typeArg$astNode = typeArg.astNode) === null ||\n            _typeArg$astNode === void 0\n              ? void 0\n              : _typeArg$astNode.type,\n          ],\n        );\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\n          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType.name} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${inspect(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType.name} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0\n          ? void 0\n          : _field$astNode2.type,\n      );\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\n        [\n          getDeprecatedDirectiveNode(field.astNode),\n          (_field$astNode3 = field.astNode) === null ||\n          _field$astNode3 === void 0\n            ? void 0\n            : _field$astNode3.type,\n        ],\n      );\n    }\n\n    if (inputObj.isOneOf) {\n      validateOneOfInputObjectField(inputObj, field, context);\n    }\n  }\n}\n\nfunction validateOneOfInputObjectField(type, field, context) {\n  if (isNonNullType(field.type)) {\n    var _field$astNode4;\n\n    context.reportError(\n      `OneOf input field ${type.name}.${field.name} must be nullable.`,\n      (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0\n        ? void 0\n        : _field$astNode4.type,\n    );\n  }\n\n  if (field.defaultValue !== undefined) {\n    context.reportError(\n      `OneOf input field ${type.name}.${field.name} cannot have a default value.`,\n      field.astNode,\n    );\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\n          context.reportError(\n            `Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const { astNode, extensionASTNodes } = type;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((typeNode) => {\n      var _typeNode$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_typeNode$interfaces = typeNode.interfaces) !== null &&\n          _typeNode$interfaces !== void 0\n          ? _typeNode$interfaces\n          : []\n      );\n    })\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const { astNode, extensionASTNodes } = union;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((unionNode) => {\n      var _unionNode$types;\n\n      return (\n        /* c8 ignore next */\n        (_unionNode$types = unionNode.types) !== null &&\n          _unionNode$types !== void 0\n          ? _unionNode$types\n          : []\n      );\n    })\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0\n    ? void 0\n    : (_definitionNode$direc = definitionNode.directives) === null ||\n      _definitionNode$direc === void 0\n    ? void 0\n    : _definitionNode$direc.find(\n        (node) => node.name.value === GraphQLDeprecatedDirective.name,\n      );\n}\n"]},"metadata":{},"sourceType":"module"}