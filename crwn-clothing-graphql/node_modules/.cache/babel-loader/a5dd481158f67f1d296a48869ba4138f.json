{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { __use, useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../internal/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nexport function useSuspenseQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n\n  return wrapHook(\"useSuspenseQuery\", _useSuspenseQuery, useApolloClient(typeof options === \"object\" ? options.client : undefined))(query, options);\n}\n\nfunction _useSuspenseQuery(query, options) {\n  var client = useApolloClient(options.client);\n  var suspenseCache = getSuspenseCache(client);\n  var watchQueryOptions = useWatchQueryOptions({\n    client: client,\n    query: query,\n    options: options\n  });\n  var fetchPolicy = watchQueryOptions.fetchPolicy,\n      variables = watchQueryOptions.variables;\n  var _a = options.queryKey,\n      queryKey = _a === void 0 ? [] : _a;\n\n  var cacheKey = __spreadArray([query, canonicalStringify(variables)], [].concat(queryKey), true);\n\n  var queryRef = suspenseCache.getQueryRef(cacheKey, function () {\n    return client.watchQuery(watchQueryOptions);\n  });\n\n  var _b = React.useState([queryRef.key, queryRef.promise]),\n      current = _b[0],\n      setPromise = _b[1]; // This saves us a re-execution of the render function when a variable changed.\n\n\n  if (current[0] !== queryRef.key) {\n    current[0] = queryRef.key;\n    current[1] = queryRef.promise;\n  }\n\n  var promise = current[1];\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    current[1] = promise = queryRef.applyOptions(watchQueryOptions);\n  }\n\n  React.useEffect(function () {\n    var dispose = queryRef.retain();\n    var removeListener = queryRef.listen(function (promise) {\n      setPromise([queryRef.key, promise]);\n    });\n    return function () {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n  var skipResult = React.useMemo(function () {\n    var error = toApolloError(queryRef.result);\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error: error\n    };\n  }, [queryRef.result]);\n  var result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n  var fetchMore = React.useCallback(function (options) {\n    var promise = queryRef.fetchMore(options);\n    setPromise([queryRef.key, queryRef.promise]);\n    return promise;\n  }, [queryRef]);\n  var refetch = React.useCallback(function (variables) {\n    var promise = queryRef.refetch(variables);\n    setPromise([queryRef.key, queryRef.promise]);\n    return promise;\n  }, [queryRef]);\n  var subscribeToMore = queryRef.observable.subscribeToMore;\n  return React.useMemo(function () {\n    return {\n      client: client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore: fetchMore,\n      refetch: refetch,\n      subscribeToMore: subscribeToMore\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\nfunction validateOptions(options) {\n  var query = options.query,\n      fetchPolicy = options.fetchPolicy,\n      returnPartialData = options.returnPartialData;\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(fetchPolicy) {\n  if (fetchPolicy === void 0) {\n    fetchPolicy = \"cache-first\";\n  }\n\n  var supportedFetchPolicies = [\"cache-first\", \"network-only\", \"no-cache\", \"cache-and-network\"];\n  invariant(supportedFetchPolicies.includes(fetchPolicy), 66, fetchPolicy);\n}\n\nfunction validatePartialDataReturn(fetchPolicy, returnPartialData) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    globalThis.__DEV__ !== false && invariant.warn(67);\n  }\n}\n\nexport function toApolloError(result) {\n  return isNonEmptyArray(result.errors) ? new ApolloError({\n    graphQLErrors: result.errors\n  }) : result.error;\n}\nexport function useWatchQueryOptions(_a) {\n  var client = _a.client,\n      query = _a.query,\n      options = _a.options;\n  return useDeepMemo(function () {\n    var _a;\n\n    if (options === skipToken) {\n      return {\n        query: query,\n        fetchPolicy: \"standby\"\n      };\n    }\n\n    var fetchPolicy = options.fetchPolicy || ((_a = client.defaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || \"cache-first\";\n\n    var watchQueryOptions = __assign(__assign({}, options), {\n      fetchPolicy: fetchPolicy,\n      query: query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0\n    });\n\n    if (globalThis.__DEV__ !== false) {\n      validateOptions(watchQueryOptions);\n    } // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n\n\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}","map":{"version":3,"mappings":"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","names":["React","invariant","ApolloError","NetworkStatus","isNonEmptyArray","useApolloClient","DocumentType","verifyDocumentType","__use","useDeepMemo","wrapHook","getSuspenseCache","canonicalStringify","skipToken","useSuspenseQuery","query","options","Object","create","_useSuspenseQuery","client","undefined","suspenseCache","watchQueryOptions","useWatchQueryOptions","variables","_a","cacheKey","concat","queryKey","queryRef","getQueryRef","watchQuery","useState","key","promise","current","setPromise","didChangeOptions","applyOptions","useEffect","dispose","retain","removeListener","listen","skipResult","useMemo","error","toApolloError","result","loading","data","networkStatus","ready","fetchPolicy","fetchMore","useCallback","refetch","subscribeToMore","observable","validateOptions","returnPartialData","Query","validateFetchPolicy","validatePartialDataReturn","supportedFetchPolicies","includes","globalThis","errors","graphQLErrors","defaultOptions","notifyOnNetworkStatusChange","nextFetchPolicy","skip"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/react/hooks/useSuspenseQuery.ts"],"sourcesContent":["import * as React from \"rehackt\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n  FetchMoreQueryOptions,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  SuspenseQueryHookOptions,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\nimport { __use, useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../internal/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nimport type { SkipToken } from \"./constants.js\";\nimport type { CacheKey, QueryKey } from \"../internal/index.js\";\nimport type { MaybeMasked, Unmasked } from \"../../masking/index.js\";\n\nexport interface UseSuspenseQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  client: ApolloClient<any>;\n  data: MaybeMasked<TData>;\n  error: ApolloError | undefined;\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  networkStatus: NetworkStatus;\n  refetch: RefetchFunction<TData, TVariables>;\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\nexport type FetchMoreFunction<TData, TVariables extends OperationVariables> = (\n  fetchMoreOptions: FetchMoreQueryOptions<TVariables, TData> & {\n    updateQuery?: (\n      previousQueryResult: Unmasked<TData>,\n      options: {\n        fetchMoreResult: Unmasked<TData>;\n        variables: TVariables;\n      }\n    ) => Unmasked<TData>;\n  }\n) => Promise<ApolloQueryResult<MaybeMasked<TData>>>;\n\nexport type RefetchFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"refetch\"];\n\nexport type SubscribeToMoreFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"subscribeToMore\"];\n\nexport function useSuspenseQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<SuspenseQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> &\n    TOptions\n): UseSuspenseQueryResult<\n  TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n    TOptions[\"returnPartialData\"] extends true ?\n      DeepPartial<TData> | undefined\n    : TData | undefined\n  : TOptions[\"returnPartialData\"] extends true ?\n    TOptions[\"skip\"] extends boolean ?\n      DeepPartial<TData> | undefined\n    : DeepPartial<TData>\n  : TOptions[\"skip\"] extends boolean ? TData | undefined\n  : TData,\n  TVariables\n>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData>, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?:\n    | SkipToken\n    | SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables> = Object.create(null)\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  return wrapHook(\n    \"useSuspenseQuery\",\n    _useSuspenseQuery,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options);\n}\n\nfunction _useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables>\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions<any, any>({\n    client,\n    query,\n    options,\n  });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  let [current, setPromise] = React.useState<\n    [QueryKey, Promise<ApolloQueryResult<any>>]\n  >([queryRef.key, queryRef.promise]);\n\n  // This saves us a re-execution of the render function when a variable changed.\n  if (current[0] !== queryRef.key) {\n    current[0] = queryRef.key;\n    current[1] = queryRef.promise;\n  }\n  let promise = current[1];\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    current[1] = promise = queryRef.applyOptions(watchQueryOptions);\n  }\n\n  React.useEffect(() => {\n    const dispose = queryRef.retain();\n\n    const removeListener = queryRef.listen((promise) => {\n      setPromise([queryRef.key, promise]);\n    });\n\n    return () => {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n\n  const skipResult = React.useMemo(() => {\n    const error = toApolloError(queryRef.result);\n\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error,\n    };\n  }, [queryRef.result]);\n\n  const result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n\n  const fetchMore = React.useCallback<\n    FetchMoreFunction<unknown, OperationVariables>\n  >(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  ) as FetchMoreFunction<TData | undefined, TVariables>;\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const subscribeToMore = queryRef.observable.subscribeToMore;\n\n  return React.useMemo<\n    UseSuspenseQueryResult<TData | undefined, TVariables>\n  >(() => {\n    return {\n      client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore,\n      refetch,\n      subscribeToMore,\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\nfunction validateOptions(options: WatchQueryOptions) {\n  const { query, fetchPolicy, returnPartialData } = options;\n\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(\n  fetchPolicy: WatchQueryFetchPolicy = \"cache-first\"\n) {\n  const supportedFetchPolicies: WatchQueryFetchPolicy[] = [\n    \"cache-first\",\n    \"network-only\",\n    \"no-cache\",\n    \"cache-and-network\",\n  ];\n\n  invariant(\n    supportedFetchPolicies.includes(fetchPolicy),\n    `The fetch policy \\`%s\\` is not supported with suspense.`,\n    fetchPolicy\n  );\n}\n\nfunction validatePartialDataReturn(\n  fetchPolicy: WatchQueryFetchPolicy | undefined,\n  returnPartialData: boolean | undefined\n) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    invariant.warn(\n      \"Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy.\"\n    );\n  }\n}\n\nexport function toApolloError(result: ApolloQueryResult<any>) {\n  return isNonEmptyArray(result.errors) ?\n      new ApolloError({ graphQLErrors: result.errors })\n    : result.error;\n}\n\ninterface UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n> {\n  client: ApolloClient<unknown>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: SkipToken | SuspenseQueryHookOptions<TData, TVariables>;\n}\n\nexport function useWatchQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  client,\n  query,\n  options,\n}: UseWatchQueryOptionsHookOptions<TData, TVariables>): WatchQueryOptions<\n  TVariables,\n  TData\n> {\n  return useDeepMemo<WatchQueryOptions<TVariables, TData>>(() => {\n    if (options === skipToken) {\n      return { query, fetchPolicy: \"standby\" };\n    }\n\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions = {\n      ...options,\n      fetchPolicy,\n      query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0,\n    };\n\n    if (__DEV__) {\n      validateOptions(watchQueryOptions);\n    }\n\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}\n"]},"metadata":{},"sourceType":"module"}