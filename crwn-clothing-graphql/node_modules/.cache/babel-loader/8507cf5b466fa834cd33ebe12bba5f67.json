{"ast":null,"code":"import { Kind } from \"graphql\";\nimport { MapImpl, SetImpl, warnOnImproperCacheImplementation } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport equal from \"@wry/equality\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport { createFragmentMap, getFragmentDefinitions } from \"../utilities/index.js\";\n/** @internal */\n\nexport function maskFragment(data, document, cache, fragmentName) {\n  if (!cache.fragmentMatches) {\n    if (globalThis.__DEV__ !== false) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  var fragments = document.definitions.filter(function (node) {\n    return node.kind === Kind.FRAGMENT_DEFINITION;\n  });\n\n  if (typeof fragmentName === \"undefined\") {\n    invariant(fragments.length === 1, 49, fragments.length);\n    fragmentName = fragments[0].name.value;\n  }\n\n  var fragment = fragments.find(function (fragment) {\n    return fragment.name.value === fragmentName;\n  });\n  invariant(!!fragment, 50, fragmentName);\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache: cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl()\n  });\n}","map":{"version":3,"mappings":"AAAA,SAASA,IAAT,QAAqB,SAArB;AAOA,SACEC,OADF,EAEEC,OAFF,EAGEC,iCAHF,QAIO,YAJP;AAKA,SAASC,SAAT,QAA0B,+BAA1B;AACA,OAAOC,KAAP,MAAkB,eAAlB;AACA,SAASC,cAAT,QAA+B,qBAA/B;AACA,SACEC,iBADF,EAEEC,sBAFF,QAGO,uBAHP;AAKA;;AACA,OAAM,SAAUC,YAAV,CACJC,IADI,EAEJC,QAFI,EAGJC,KAHI,EAIJC,YAJI,EAIiB;AAErB,MAAI,CAACD,KAAK,CAACE,eAAX,EAA4B;AAC1B,QAAIC,UAAU,QAAV,KAAU,KAAd,EAAc;AACZZ,uCAAiC;AAClC;;AAED,WAAOO,IAAP;AACD;;AAED,MAAMM,SAAS,GAAGL,QAAQ,CAACM,WAAT,CAAqBC,MAArB,CAChB,UAACC,IAAD,EAAK;AACH,eAAI,CAACC,IAAL,KAAcpB,IAAI,CAACqB,mBAAnB;AAAsC,GAFxB,CAAlB;;AAKA,MAAI,OAAOR,YAAP,KAAwB,WAA5B,EAAyC;AACvCT,aAAS,CACPY,SAAS,CAACM,MAAV,KAAqB,CADd,EAEP,EAFO,EAEPN,gBAFO,CAAT;AAKAH,gBAAY,GAAGG,SAAS,CAAC,CAAD,CAAT,CAAaO,IAAb,CAAkBC,KAAjC;AACD;;AAED,MAAMC,QAAQ,GAAGT,SAAS,CAACU,IAAV,CACf,UAACD,QAAD,EAAS;AAAK,mBAAQ,CAACF,IAAT,CAAcC,KAAd,KAAwBX,YAAxB;AAAoC,GADnC,CAAjB;AAIAT,WAAS,CACP,CAAC,CAACqB,QADK,EAEP,EAFO,EAEPZ,YAFO,CAAT;;AAMA,MAAIH,IAAI,IAAI,IAAZ,EAAkB;AAChB;AACA,WAAOA,IAAP;AACD;;AAED,MAAIL,KAAK,CAACK,IAAD,EAAO,EAAP,CAAT,EAAqB;AACnB;AACA;AACA;AACA,WAAOA,IAAP;AACD;;AAED,SAAOJ,cAAc,CAACI,IAAD,EAAOe,QAAQ,CAACE,YAAhB,EAA8B;AACjDC,iBAAa,EAAE,UADkC;AAEjDC,iBAAa,EAAEJ,QAAQ,CAACF,IAAT,CAAcC,KAFoB;AAGjDM,eAAW,EAAEvB,iBAAiB,CAACC,sBAAsB,CAACG,QAAD,CAAvB,CAHmB;AAIjDC,SAAK,OAJ4C;AAKjDmB,kBAAc,EAAE,IAAI9B,OAAJ,EALiC;AAMjD+B,gBAAY,EAAE,IAAI9B,OAAJ;AANmC,GAA9B,CAArB;AAQD","names":["Kind","MapImpl","SetImpl","warnOnImproperCacheImplementation","invariant","equal","maskDefinition","createFragmentMap","getFragmentDefinitions","maskFragment","data","document","cache","fragmentName","fragmentMatches","globalThis","fragments","definitions","filter","node","kind","FRAGMENT_DEFINITION","length","name","value","fragment","find","selectionSet","operationType","operationName","fragmentMap","mutableTargets","knownChanged"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/masking/maskFragment.ts"],"sourcesContent":["import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode } from \"graphql\";\nimport type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport equal from \"@wry/equality\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n} from \"../utilities/index.js\";\n\n/** @internal */\nexport function maskFragment<TData = unknown>(\n  data: TData,\n  document: TypedDocumentNode<TData> | DocumentNode,\n  cache: ApolloCache<unknown>,\n  fragmentName?: string\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const fragments = document.definitions.filter(\n    (node): node is FragmentDefinitionNode =>\n      node.kind === Kind.FRAGMENT_DEFINITION\n  );\n\n  if (typeof fragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    fragmentName = fragments[0].name.value;\n  }\n\n  const fragment = fragments.find(\n    (fragment) => fragment.name.value === fragmentName\n  );\n\n  invariant(\n    !!fragment,\n    `Could not find fragment with name \"%s\".`,\n    fragmentName\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n"]},"metadata":{},"sourceType":"module"}