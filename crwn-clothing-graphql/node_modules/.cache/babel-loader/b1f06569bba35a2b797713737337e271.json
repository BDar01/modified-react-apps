{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\"; // Make builtins like Map and Set safe to use with non-extensible objects.\n\nimport \"./fixPolyfills.js\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { addTypenameToDocument, isReference, DocumentTransform, canonicalStringify, print, cacheSizes } from \"../../utilities/index.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport { getInMemoryCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\n\nvar InMemoryCache =\n/** @class */\nfunction (_super) {\n  __extends(InMemoryCache, _super);\n\n  function InMemoryCache(config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.watches = new Set();\n    _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument); // Override the default value, since InMemoryCache result objects are frozen\n    // in development and expected to remain logically immutable in production.\n\n    _this.assumeImmutableResults = true;\n    _this.makeVar = makeVar;\n    _this.txCount = 0;\n    _this.config = normalizeConfig(config);\n    _this.addTypename = !!_this.config.addTypename;\n    _this.policies = new Policies({\n      cache: _this,\n      dataIdFromObject: _this.config.dataIdFromObject,\n      possibleTypes: _this.config.possibleTypes,\n      typePolicies: _this.config.typePolicies\n    });\n\n    _this.init();\n\n    return _this;\n  }\n\n  InMemoryCache.prototype.init = function () {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    var rootStore = this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching\n    }); // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n\n    this.optimisticData = rootStore.stump;\n    this.resetResultCache();\n  };\n\n  InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {\n    var _this = this;\n\n    var previousReader = this.storeReader;\n    var fragments = this.config.fragments; // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n\n    this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({\n      cache: this,\n      addTypename: this.addTypename,\n      resultCacheMaxSize: this.config.resultCacheMaxSize,\n      canonizeResults: shouldCanonizeResults(this.config),\n      canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,\n      fragments: fragments\n    }), fragments);\n    this.maybeBroadcastWatch = wrap(function (c, options) {\n      return _this.broadcastWatch(c, options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] || 5000\n      /* defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] */\n      ,\n      makeCacheKey: function (c) {\n        // Return a cache key (thus enabling result caching) only if we're\n        // currently using a data store that can track cache dependencies.\n        var store = c.optimistic ? _this.optimisticData : _this.data;\n\n        if (supportsResultCaching(store)) {\n          var optimistic = c.optimistic,\n              id = c.id,\n              variables = c.variables;\n          return store.makeCacheKey(c.query, // Different watches can have the same query, optimistic\n          // status, rootId, and variables, but if their callbacks are\n          // different, the (identical) result needs to be delivered to\n          // each distinct callback. The easiest way to achieve that\n          // separation is to include c.callback in the cache key for\n          // maybeBroadcastWatch calls. See issue #5733.\n          c.callback, canonicalStringify({\n            optimistic: optimistic,\n            id: id,\n            variables: variables\n          }));\n        }\n      }\n    }); // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n\n    new Set([this.data.group, this.optimisticData.group]).forEach(function (group) {\n      return group.resetCaching();\n    });\n  };\n\n  InMemoryCache.prototype.restore = function (data) {\n    this.init(); // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n\n    if (data) this.data.replace(data);\n    return this;\n  };\n\n  InMemoryCache.prototype.extract = function (optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n\n    return (optimistic ? this.optimisticData : this.data).extract();\n  };\n\n  InMemoryCache.prototype.read = function (options) {\n    var // Since read returns data or null, without any additional metadata\n    // about whether/where there might have been missing fields, the\n    // default behavior cannot be returnPartialData = true (like it is\n    // for the diff method), since defaulting to true would violate the\n    // integrity of the T in the return type. However, partial data may\n    // be useful in some cases, so returnPartialData:true may be\n    // specified explicitly.\n    _a = options.returnPartialData,\n        // Since read returns data or null, without any additional metadata\n    // about whether/where there might have been missing fields, the\n    // default behavior cannot be returnPartialData = true (like it is\n    // for the diff method), since defaulting to true would violate the\n    // integrity of the T in the return type. However, partial data may\n    // be useful in some cases, so returnPartialData:true may be\n    // specified explicitly.\n    returnPartialData = _a === void 0 ? false : _a;\n\n    try {\n      return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {\n        store: options.optimistic ? this.optimisticData : this.data,\n        config: this.config,\n        returnPartialData: returnPartialData\n      })).result || null;\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not need to\n        // worry about catching \"normal\" exceptions resulting from incomplete\n        // cache data. Unexpected errors will be re-thrown. If you need more\n        // information about which fields were missing, use cache.diff instead,\n        // and examine diffResult.missing.\n        return null;\n      }\n\n      throw e;\n    }\n  };\n\n  InMemoryCache.prototype.write = function (options) {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n\n  InMemoryCache.prototype.modify = function (options) {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n\n    var store = options.optimistic // Defaults to false.\n    ? this.optimisticData : this.data;\n\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n\n  InMemoryCache.prototype.diff = function (options) {\n    return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config\n    }));\n  };\n\n  InMemoryCache.prototype.watch = function (watch) {\n    var _this = this;\n\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n\n    this.watches.add(watch);\n\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n\n    return function () {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (_this.watches.delete(watch) && !_this.watches.size) {\n        forgetCache(_this);\n      } // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n\n\n      _this.maybeBroadcastWatch.forget(watch);\n    };\n  };\n\n  InMemoryCache.prototype.gc = function (options) {\n    var _a;\n\n    canonicalStringify.reset();\n    print.reset();\n    this.addTypenameTransform.resetCache();\n    (_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.resetCaches();\n    var ids = this.optimisticData.gc();\n\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n\n    return ids;\n  }; // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n\n\n  InMemoryCache.prototype.retain = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }; // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n\n\n  InMemoryCache.prototype.release = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }; // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n\n\n  InMemoryCache.prototype.identify = function (object) {\n    if (isReference(object)) return object.__ref;\n\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      globalThis.__DEV__ !== false && invariant.warn(e);\n    }\n  };\n\n  InMemoryCache.prototype.evict = function (options) {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n\n      options = __assign(__assign({}, options), {\n        id: \"ROOT_QUERY\"\n      });\n    }\n\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount; // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n\n  InMemoryCache.prototype.reset = function (options) {\n    var _this = this;\n\n    this.init();\n    canonicalStringify.reset();\n\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach(function (watch) {\n        return _this.maybeBroadcastWatch.forget(watch);\n      });\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n\n    return Promise.resolve();\n  };\n\n  InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n    var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  };\n\n  InMemoryCache.prototype.batch = function (options) {\n    var _this = this;\n\n    var update = options.update,\n        _a = options.optimistic,\n        optimistic = _a === void 0 ? true : _a,\n        removeOptimistic = options.removeOptimistic,\n        onWatchUpdated = options.onWatchUpdated;\n    var updateResult;\n\n    var perform = function (layer) {\n      var _a = _this,\n          data = _a.data,\n          optimisticData = _a.optimisticData;\n      ++_this.txCount;\n\n      if (layer) {\n        _this.data = _this.optimisticData = layer;\n      }\n\n      try {\n        return updateResult = update(_this);\n      } finally {\n        --_this.txCount;\n        _this.data = data;\n        _this.optimisticData = optimisticData;\n      }\n    };\n\n    var alreadyDirty = new Set();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches(__assign(__assign({}, options), {\n        onWatchUpdated: function (watch) {\n          alreadyDirty.add(watch);\n          return false;\n        }\n      }));\n    }\n\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    } // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n\n\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches(__assign(__assign({}, options), {\n        onWatchUpdated: function (watch, diff) {\n          var result = onWatchUpdated.call(this, watch, diff);\n\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n\n          return result;\n        }\n      })); // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach(function (watch) {\n          return _this.maybeBroadcastWatch.dirty(watch);\n        });\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n\n    return updateResult;\n  };\n\n  InMemoryCache.prototype.performTransaction = function (update, optimisticId) {\n    return this.batch({\n      update: update,\n      optimistic: optimisticId || optimisticId !== null\n    });\n  };\n\n  InMemoryCache.prototype.transformDocument = function (document) {\n    return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n  };\n\n  InMemoryCache.prototype.fragmentMatches = function (fragment, typename) {\n    return this.policies.fragmentMatches(fragment, typename);\n  };\n\n  InMemoryCache.prototype.lookupFragment = function (fragmentName) {\n    var _a;\n\n    return ((_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.lookup(fragmentName)) || null;\n  };\n\n  InMemoryCache.prototype.broadcastWatches = function (options) {\n    var _this = this;\n\n    if (!this.txCount) {\n      this.watches.forEach(function (c) {\n        return _this.maybeBroadcastWatch(c, options);\n      });\n    }\n  };\n\n  InMemoryCache.prototype.addFragmentsToDocument = function (document) {\n    var fragments = this.config.fragments;\n    return fragments ? fragments.transform(document) : document;\n  };\n\n  InMemoryCache.prototype.addTypenameToDocument = function (document) {\n    if (this.addTypename) {\n      return this.addTypenameTransform.transformDocument(document);\n    }\n\n    return document;\n  }; // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n\n\n  InMemoryCache.prototype.broadcastWatch = function (c, options) {\n    var lastDiff = c.lastDiff; // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n\n    var diff = this.diff(c);\n\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback(c.lastDiff = diff, lastDiff);\n    }\n  };\n\n  return InMemoryCache;\n}(ApolloCache);\n\nexport { InMemoryCache };\n\nif (globalThis.__DEV__ !== false) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}","map":{"version":3,"mappings":"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","names":["invariant","wrap","equal","ApolloCache","MissingFieldError","addTypenameToDocument","isReference","DocumentTransform","canonicalStringify","print","cacheSizes","StoreReader","StoreWriter","EntityStore","supportsResultCaching","makeVar","forgetCache","recallCache","Policies","hasOwn","normalizeConfig","shouldCanonizeResults","getInMemoryCacheMemoryInternals","__extends","config","_this","Set","addTypename","policies","cache","dataIdFromObject","possibleTypes","typePolicies","init","InMemoryCache","rootStore","data","Root","resultCaching","optimisticData","stump","resetResultCache","resetResultIdentities","previousReader","storeReader","fragments","storeWriter","resultCacheMaxSize","canonizeResults","canon","maybeBroadcastWatch","c","options","broadcastWatch","max","makeCacheKey","store","optimistic","id","variables","query","callback","group","forEach","resetCaching","replace","extract","_a","returnPartialData","diffQueryAgainstStore","__assign","result","e","txCount","writeToStore","broadcast","broadcastWatches","call","modify","fields","rootId","watch","watches","size","add","immediate","delete","forget","reset","addTypenameTransform","resetCache","resetCaches","ids","gc","resetCanon","retain","release","object","__ref","identify","globalThis","evict","discardWatches","clear","Promise","resolve","idToRemove","newOptimisticData","removeLayer","removeOptimistic","onWatchUpdated","updateResult","perform","layer","update","alreadyDirty","addLayer","diff","dirty","optimisticId","batch","document","addFragmentsToDocument","fragment","typename","fragmentMatches","fragmentName","lookup","transform","transformDocument","fromOptimisticTransaction","lastDiff","prototype","getMemoryInternals"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/cache/inmemory/inMemoryCache.ts"],"sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\n\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\n\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\n\nimport { ApolloCache } from \"../core/cache.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport type { StoreObject, Reference } from \"../../utilities/index.js\";\nimport {\n  addTypenameToDocument,\n  isReference,\n  DocumentTransform,\n  canonicalStringify,\n  print,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport type { InMemoryCacheConfig, NormalizedCacheObject } from \"./types.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { getInMemoryCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\n\ntype BroadcastOptions = Pick<\n  Cache.BatchOptions<InMemoryCache>,\n  \"optimistic\" | \"onWatchUpdated\"\n>;\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data!: EntityStore;\n  private optimisticData!: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n\n  private storeReader!: StoreReader;\n  private storeWriter!: StoreWriter;\n  private addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n\n  private maybeBroadcastWatch!: OptimisticWrapperFunction<\n    [Cache.WatchOptions, BroadcastOptions?],\n    any,\n    [Cache.WatchOptions]\n  >;\n\n  // Override the default value, since InMemoryCache result objects are frozen\n  // in development and expected to remain logically immutable in production.\n  public readonly assumeImmutableResults = true;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = normalizeConfig(config);\n    this.addTypename = !!this.config.addTypename;\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    this.init();\n  }\n\n  private init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = (this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    }));\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n\n    this.resetResultCache();\n  }\n\n  private resetResultCache(resetResultIdentities?: boolean) {\n    const previousReader = this.storeReader;\n    const { fragments } = this.config;\n\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(\n      this,\n      (this.storeReader = new StoreReader({\n        cache: this,\n        addTypename: this.addTypename,\n        resultCacheMaxSize: this.config.resultCacheMaxSize,\n        canonizeResults: shouldCanonizeResults(this.config),\n        canon:\n          resetResultIdentities ? void 0 : (\n            previousReader && previousReader.canon\n          ),\n        fragments,\n      })),\n      fragments\n    );\n\n    this.maybeBroadcastWatch = wrap(\n      (c: Cache.WatchOptions, options?: BroadcastOptions) => {\n        return this.broadcastWatch(c, options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] ||\n          defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"],\n        makeCacheKey: (c: Cache.WatchOptions) => {\n          // Return a cache key (thus enabling result caching) only if we're\n          // currently using a data store that can track cache dependencies.\n          const store = c.optimistic ? this.optimisticData : this.data;\n          if (supportsResultCaching(store)) {\n            const { optimistic, id, variables } = c;\n            return store.makeCacheKey(\n              c.query,\n              // Different watches can have the same query, optimistic\n              // status, rootId, and variables, but if their callbacks are\n              // different, the (identical) result needs to be delivered to\n              // each distinct callback. The easiest way to achieve that\n              // separation is to include c.callback in the cache key for\n              // maybeBroadcastWatch calls. See issue #5733.\n              c.callback,\n              canonicalStringify({ optimistic, id, variables })\n            );\n          }\n        },\n      }\n    );\n\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach((group) =>\n      group.resetCaching()\n    );\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n    try {\n      return (\n        this.storeReader.diffQueryAgainstStore<T>({\n          ...options,\n          store: options.optimistic ? this.optimisticData : this.data,\n          config: this.config,\n          returnPartialData,\n        }).result || null\n      );\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not need to\n        // worry about catching \"normal\" exceptions resulting from incomplete\n        // cache data. Unexpected errors will be re-thrown. If you need more\n        // information about which fields were missing, use cache.diff instead,\n        // and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  public write(options: Cache.WriteOptions): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store =\n      (\n        options.optimistic // Defaults to false.\n      ) ?\n        this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<TData, TVariables extends OperationVariables = any>(\n    options: Cache.DiffOptions<TData, TVariables>\n  ): Cache.DiffResult<TData> {\n    return this.storeReader.diffQueryAgainstStore({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config,\n    });\n  }\n\n  public watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>\n  ): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  public gc(options?: {\n    // If true, also free non-essential result cache memory by bulk-releasing\n    // this.{store{Reader,Writer},maybeBroadcastWatch}. Defaults to false.\n    resetResultCache?: boolean;\n    // If resetResultCache is true, this.storeReader.canon will be preserved by\n    // default, but can also be discarded by passing resetResultIdentities:true.\n    // Defaults to false.\n    resetResultIdentities?: boolean;\n  }) {\n    canonicalStringify.reset();\n    print.reset();\n    this.addTypenameTransform.resetCache();\n    this.config.fragments?.resetCaches();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      invariant.warn(e);\n    }\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(options?: Cache.ResetOptions): Promise<void> {\n    this.init();\n\n    canonicalStringify.reset();\n\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach((watch) => this.maybeBroadcastWatch.forget(watch));\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public batch<TUpdateResult>(\n    options: Cache.BatchOptions<InMemoryCache, TUpdateResult>\n  ): TUpdateResult {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated,\n    } = options;\n\n    let updateResult: TUpdateResult;\n    const perform = (layer?: EntityStore): TUpdateResult => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        return (updateResult = update(this));\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    const alreadyDirty = new Set<Cache.WatchOptions>();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        },\n      });\n    }\n\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        },\n      });\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach((watch) => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n\n    return updateResult!;\n  }\n\n  public performTransaction(\n    update: (cache: InMemoryCache) => any,\n    optimisticId?: string | null\n  ) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || optimisticId !== null,\n    });\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode,\n    typename: string\n  ): boolean {\n    return this.policies.fragmentMatches(fragment, typename);\n  }\n\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return this.config.fragments?.lookup(fragmentName) || null;\n  }\n\n  protected broadcastWatches(options?: BroadcastOptions) {\n    if (!this.txCount) {\n      this.watches.forEach((c) => this.maybeBroadcastWatch(c, options));\n    }\n  }\n\n  private addFragmentsToDocument(document: DocumentNode) {\n    const { fragments } = this.config;\n    return fragments ? fragments.transform(document) : document;\n  }\n\n  private addTypenameToDocument(document: DocumentNode) {\n    if (this.addTypename) {\n      return this.addTypenameTransform.transformDocument(document);\n    }\n    return document;\n  }\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(c: Cache.WatchOptions, options?: BroadcastOptions) {\n    const { lastDiff } = c;\n\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    const diff = this.diff<any>(c);\n\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (\n        options.onWatchUpdated &&\n        options.onWatchUpdated.call(this, c, diff, lastDiff) === false\n      ) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback((c.lastDiff = diff), lastDiff);\n    }\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n"]},"metadata":{},"sourceType":"module"}