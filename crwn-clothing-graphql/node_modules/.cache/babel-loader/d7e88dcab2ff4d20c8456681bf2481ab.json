{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { getSuspenseCache, unwrapQueryRef, updateWrappedQueryRef, wrapQueryRef } from \"../internal/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nexport function useBackgroundQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n\n  return wrapHook(\"useBackgroundQuery\", _useBackgroundQuery, useApolloClient(typeof options === \"object\" ? options.client : undefined))(query, options);\n}\n\nfunction _useBackgroundQuery(query, options) {\n  var client = useApolloClient(options.client);\n  var suspenseCache = getSuspenseCache(client);\n  var watchQueryOptions = useWatchQueryOptions({\n    client: client,\n    query: query,\n    options: options\n  });\n  var fetchPolicy = watchQueryOptions.fetchPolicy,\n      variables = watchQueryOptions.variables;\n  var _a = options.queryKey,\n      queryKey = _a === void 0 ? [] : _a; // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n\n  var didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current || (didFetchResult.current = fetchPolicy !== \"standby\");\n\n  var cacheKey = __spreadArray([query, canonicalStringify(variables)], [].concat(queryKey), true);\n\n  var queryRef = suspenseCache.getQueryRef(cacheKey, function () {\n    return client.watchQuery(watchQueryOptions);\n  });\n\n  var _b = React.useState(wrapQueryRef(queryRef)),\n      wrappedQueryRef = _b[0],\n      setWrappedQueryRef = _b[1];\n\n  if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n  }\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    var promise = queryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(wrappedQueryRef, promise);\n  } // This prevents issues where rerendering useBackgroundQuery after the\n  // queryRef has been disposed would cause the hook to return a new queryRef\n  // instance since disposal also removes it from the suspense cache. We add\n  // the queryRef back in the suspense cache so that the next render will reuse\n  // this queryRef rather than initializing a new instance.\n\n\n  React.useEffect(function () {\n    // Since the queryRef is disposed async via `setTimeout`, we have to wait a\n    // tick before checking it and adding back to the suspense cache.\n    var id = setTimeout(function () {\n      if (queryRef.disposed) {\n        suspenseCache.add(cacheKey, queryRef);\n      }\n    });\n    return function () {\n      return clearTimeout(id);\n    }; // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n  var fetchMore = React.useCallback(function (options) {\n    var promise = queryRef.fetchMore(options);\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n    return promise;\n  }, [queryRef]);\n  var refetch = React.useCallback(function (variables) {\n    var promise = queryRef.refetch(variables);\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n    return promise;\n  }, [queryRef]);\n  React.useEffect(function () {\n    return queryRef.softRetain();\n  }, [queryRef]);\n  return [didFetchResult.current ? wrappedQueryRef : void 0, {\n    fetchMore: fetchMore,\n    refetch: refetch,\n    subscribeToMore: queryRef.observable.subscribeToMore\n  }];\n}","map":{"version":3,"mappings":"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","names":["React","useApolloClient","getSuspenseCache","unwrapQueryRef","updateWrappedQueryRef","wrapQueryRef","wrapHook","useWatchQueryOptions","canonicalStringify","useBackgroundQuery","query","options","Object","create","_useBackgroundQuery","client","undefined","suspenseCache","watchQueryOptions","variables","_a","didFetchResult","useRef","fetchPolicy","current","cacheKey","concat","queryKey","queryRef","getQueryRef","watchQuery","useState","wrappedQueryRef","setWrappedQueryRef","didChangeOptions","promise","applyOptions","useEffect","id","setTimeout","disposed","add","fetchMore","useCallback","refetch","softRetain","subscribeToMore","observable"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/react/hooks/useBackgroundQuery.ts"],"sourcesContent":["import * as React from \"rehackt\";\nimport type {\n  DocumentNode,\n  FetchMoreQueryOptions,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  getSuspenseCache,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type { CacheKey, QueryRef } from \"../internal/index.js\";\nimport type { BackgroundQueryHookOptions, NoInfer } from \"../types/types.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport type {\n  FetchMoreFunction,\n  RefetchFunction,\n  SubscribeToMoreFunction,\n} from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport type { SkipToken } from \"./constants.js\";\n\nexport type UseBackgroundQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)} */\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#refetch:member(1)} */\n  refetch: RefetchFunction<TData, TVariables>;\n};\n\ntype BackgroundQueryHookOptionsNoInfer<\n  TData,\n  TVariables extends OperationVariables,\n> = BackgroundQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>;\n\nexport function useBackgroundQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<BackgroundQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & TOptions\n): [\n  (\n    | QueryRef<\n        TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n          TOptions[\"returnPartialData\"] extends true ?\n            DeepPartial<TData> | undefined\n          : TData | undefined\n        : TOptions[\"returnPartialData\"] extends true ? DeepPartial<TData>\n        : TData,\n        TVariables\n      >\n    | (TOptions[\"skip\"] extends boolean ? undefined : never)\n  ),\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<DeepPartial<TData> | undefined, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<TData | undefined, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): [\n  QueryRef<DeepPartial<TData>, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n  }\n): [\n  QueryRef<DeepPartial<TData>, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n  }\n): [\n  QueryRef<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [QueryRef<TData, TVariables>, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): [undefined, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n        returnPartialData: true;\n      })\n): [\n  QueryRef<DeepPartial<TData>, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryRef<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken &\n        Partial<BackgroundQueryHookOptionsNoInfer<TData, TVariables>>)\n    | BackgroundQueryHookOptionsNoInfer<TData, TVariables> = Object.create(null)\n): [\n  QueryRef<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n] {\n  return wrapHook(\n    \"useBackgroundQuery\",\n    _useBackgroundQuery,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options);\n}\n\nfunction _useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken &\n        Partial<BackgroundQueryHookOptionsNoInfer<TData, TVariables>>)\n    | BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryRef<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n] {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  const didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current ||= fetchPolicy !== \"standby\";\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions as WatchQueryOptions<any, any>)\n  );\n\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(\n    wrapQueryRef(queryRef)\n  );\n  if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n  }\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    const promise = queryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(wrappedQueryRef, promise);\n  }\n\n  // This prevents issues where rerendering useBackgroundQuery after the\n  // queryRef has been disposed would cause the hook to return a new queryRef\n  // instance since disposal also removes it from the suspense cache. We add\n  // the queryRef back in the suspense cache so that the next render will reuse\n  // this queryRef rather than initializing a new instance.\n  React.useEffect(() => {\n    // Since the queryRef is disposed async via `setTimeout`, we have to wait a\n    // tick before checking it and adding back to the suspense cache.\n    const id = setTimeout(() => {\n      if (queryRef.disposed) {\n        suspenseCache.add(cacheKey, queryRef);\n      }\n    });\n\n    return () => clearTimeout(id);\n    // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options as FetchMoreQueryOptions<any>);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  React.useEffect(() => queryRef.softRetain(), [queryRef]);\n\n  return [\n    didFetchResult.current ? wrappedQueryRef : void 0,\n    {\n      fetchMore,\n      refetch,\n      subscribeToMore: queryRef.observable.subscribeToMore,\n    },\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}