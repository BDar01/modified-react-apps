{"ast":null,"code":"import { Slot } from \"./slot.js\";\nexport { Slot };\nexport const {\n  bind,\n  noContext\n} = Slot; // Like global.setTimeout, except the callback runs with captured context.\n\nexport { setTimeoutWithContext as setTimeout };\n\nfunction setTimeoutWithContext(callback, delay) {\n  return setTimeout(bind(callback), delay);\n} // Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\n\n\nexport function asyncFromGen(genFn) {\n  return function () {\n    const gen = genFn.apply(this, arguments);\n    const boundNext = bind(gen.next);\n    const boundThrow = bind(gen.throw);\n    return new Promise((resolve, reject) => {\n      function invoke(method, argument) {\n        try {\n          var result = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n\n        const next = result.done ? resolve : invokeNext;\n\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n\n      const invokeNext = value => invoke(boundNext, value);\n\n      const invokeThrow = error => invoke(boundThrow, error);\n\n      invokeNext();\n    });\n  };\n}\n\nfunction isPromiseLike(value) {\n  return value && typeof value.then === \"function\";\n} // If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\n\n\nconst wrappedFibers = [];\nexport function wrapYieldingFiberMethods(Fiber) {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj, method) => {\n      const fn = obj[method];\n\n      obj[method] = function () {\n        return noContext(fn, arguments, this);\n      };\n    }; // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n\n\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n\n  return Fiber;\n}","map":{"version":3,"mappings":"AAAA,SAASA,IAAT,QAAqB,WAArB;AACA,SAASA,IAAT;AACA,OAAO,MAAM;AAAEC,MAAF;AAAQC;AAAR,IAAsBF,IAA5B,C,CAUP;;AACA,SAASG,qBAAqB,IAAIC,UAAlC;;AACA,SAASD,qBAAT,CAA+BE,QAA/B,EAAoDC,KAApD,EAAiE;AAC/D,SAAOF,UAAU,CAACH,IAAI,CAACI,QAAD,CAAL,EAAiBC,KAAjB,CAAjB;AACD,C,CAED;AACA;;;AACA,OAAM,SAAUC,YAAV,CAMJC,KANI,EAMwD;AAE5D,SAAO;AACL,UAAMC,GAAG,GAAGD,KAAK,CAACE,KAAN,CAAY,IAAZ,EAAkBC,SAAlB,CAAZ;AAOA,UAAMC,SAAS,GAAWX,IAAI,CAACQ,GAAG,CAACI,IAAL,CAA9B;AACA,UAAMC,UAAU,GAAWb,IAAI,CAACQ,GAAG,CAACM,KAAL,CAA/B;AAEA,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;AACrC,eAASC,MAAT,CAAgBC,MAAhB,EAAgCC,QAAhC,EAA6C;AAC3C,YAAI;AACF,cAAIC,MAAM,GAAQF,MAAM,CAACG,IAAP,CAAYd,GAAZ,EAAiBY,QAAjB,CAAlB;AACD,SAFD,CAEE,OAAOG,KAAP,EAAc;AACd,iBAAON,MAAM,CAACM,KAAD,CAAb;AACD;;AACD,cAAMX,IAAI,GAAGS,MAAM,CAACG,IAAP,GAAcR,OAAd,GAAwBS,UAArC;;AACA,YAAIC,aAAa,CAACL,MAAM,CAACM,KAAR,CAAjB,EAAiC;AAC/BN,gBAAM,CAACM,KAAP,CAAaC,IAAb,CAAkBhB,IAAlB,EAAwBS,MAAM,CAACG,IAAP,GAAcP,MAAd,GAAuBY,WAA/C;AACD,SAFD,MAEO;AACLjB,cAAI,CAACS,MAAM,CAACM,KAAR,CAAJ;AACD;AACF;;AACD,YAAMF,UAAU,GAAIE,KAAD,IAAiBT,MAAM,CAACP,SAAD,EAAYgB,KAAZ,CAA1C;;AACA,YAAME,WAAW,GAAIN,KAAD,IAAgBL,MAAM,CAACL,UAAD,EAAaU,KAAb,CAA1C;;AACAE,gBAAU;AACX,KAjBM,CAAP;AAkBmC,GA7BrC;AA8BD;;AAED,SAASC,aAAT,CAAuBC,KAAvB,EAAiC;AAC/B,SAAOA,KAAK,IAAI,OAAOA,KAAK,CAACC,IAAb,KAAsB,UAAtC;AACD,C,CAED;AACA;AACA;;;AACA,MAAME,aAAa,GAAe,EAAlC;AACA,OAAM,SAAUC,wBAAV,CAAuDC,KAAvD,EAA+D;AACnE;AACA;AACA,MAAIF,aAAa,CAACG,OAAd,CAAsBD,KAAtB,IAA+B,CAAnC,EAAsC;AACpC,UAAME,IAAI,GAAG,CAACC,GAAD,EAAWhB,MAAX,KAA6B;AACxC,YAAMiB,EAAE,GAAGD,GAAG,CAAChB,MAAD,CAAd;;AACAgB,SAAG,CAAChB,MAAD,CAAH,GAAc;AACZ,eAAOlB,SAAS,CAACmC,EAAD,EAAK1B,SAAL,EAAuB,IAAvB,CAAhB;AACD,OAFD;AAGD,KALD,CADoC,CAOpC;AACA;;;AACAwB,QAAI,CAACF,KAAD,EAAQ,OAAR,CAAJ;AACAE,QAAI,CAACF,KAAK,CAACK,SAAP,EAAkB,KAAlB,CAAJ;AACAH,QAAI,CAACF,KAAK,CAACK,SAAP,EAAkB,WAAlB,CAAJ;AACAP,iBAAa,CAACQ,IAAd,CAAmBN,KAAnB;AACD;;AACD,SAAOA,KAAP;AACD","names":["Slot","bind","noContext","setTimeoutWithContext","setTimeout","callback","delay","asyncFromGen","genFn","gen","apply","arguments","boundNext","next","boundThrow","throw","Promise","resolve","reject","invoke","method","argument","result","call","error","done","invokeNext","isPromiseLike","value","then","invokeThrow","wrappedFibers","wrapYieldingFiberMethods","Fiber","indexOf","wrap","obj","fn","prototype","push"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@wry/context/src/index.ts"],"sourcesContent":["import { Slot } from \"./slot.js\";\nexport { Slot }\nexport const { bind, noContext } = Slot;\n\n// Relying on the @types/node declaration of global.setTimeout can make\n// things tricky for dowstream projects (see PR #7).\ndeclare function setTimeout(\n  callback: (...args: any[]) => any,\n  ms?: number,\n  ...args: any[]\n): any;\n\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback: () => any, delay: number) {\n  return setTimeout(bind(callback), delay);\n}\n\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen<\n  TArgs extends any[],\n  TYield = any,\n  TReturn = any,\n  TNext = any,\n>(\n  genFn: (...args: TArgs) => Generator<TYield, TReturn, TNext>\n) {\n  return function (this: any) {\n    const gen = genFn.apply(this, arguments as any);\n\n    type Method = (\n      this: Generator<TYield, TReturn, TNext>,\n      arg: any,\n    ) => IteratorResult<TYield, TReturn>;\n\n    const boundNext: Method = bind(gen.next);\n    const boundThrow: Method = bind(gen.throw!);\n\n    return new Promise((resolve, reject) => {\n      function invoke(method: Method, argument: any) {\n        try {\n          var result: any = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        const next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      const invokeNext = (value?: any) => invoke(boundNext, value);\n      const invokeThrow = (error: any) => invoke(boundThrow, error);\n      invokeNext();\n    });\n  } as (...args: TArgs) => Promise<any>;\n}\n\nfunction isPromiseLike(value: any): value is PromiseLike<any> {\n  return value && typeof value.then === \"function\";\n}\n\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers: Function[] = [];\nexport function wrapYieldingFiberMethods<F extends Function>(Fiber: F): F {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj: any, method: string) => {\n      const fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments as any, this);\n      };\n    }\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}\n"]},"metadata":{},"sourceType":"module"}