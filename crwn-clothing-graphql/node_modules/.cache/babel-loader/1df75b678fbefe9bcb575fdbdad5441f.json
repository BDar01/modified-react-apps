{"ast":null,"code":"import { newInvariantError, invariant } from \"../../utilities/globals/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport { validateOperation, createOperation, transformOperation } from \"../utils/index.js\";\n\nfunction passthrough(op, forward) {\n  return forward ? forward(op) : Observable.of();\n}\n\nfunction toLink(handler) {\n  return typeof handler === \"function\" ? new ApolloLink(handler) : handler;\n}\n\nfunction isTerminating(link) {\n  return link.request.length <= 1;\n}\n\nvar ApolloLink =\n/** @class */\nfunction () {\n  function ApolloLink(request) {\n    if (request) this.request = request;\n  }\n\n  ApolloLink.empty = function () {\n    return new ApolloLink(function () {\n      return Observable.of();\n    });\n  };\n\n  ApolloLink.from = function (links) {\n    if (links.length === 0) return ApolloLink.empty();\n    return links.map(toLink).reduce(function (x, y) {\n      return x.concat(y);\n    });\n  };\n\n  ApolloLink.split = function (test, left, right) {\n    var leftLink = toLink(left);\n    var rightLink = toLink(right || new ApolloLink(passthrough));\n    var ret;\n\n    if (isTerminating(leftLink) && isTerminating(rightLink)) {\n      ret = new ApolloLink(function (operation) {\n        return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();\n      });\n    } else {\n      ret = new ApolloLink(function (operation, forward) {\n        return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();\n      });\n    }\n\n    return Object.assign(ret, {\n      left: leftLink,\n      right: rightLink\n    });\n  };\n\n  ApolloLink.execute = function (link, operation) {\n    return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();\n  };\n\n  ApolloLink.concat = function (first, second) {\n    var firstLink = toLink(first);\n\n    if (isTerminating(firstLink)) {\n      globalThis.__DEV__ !== false && invariant.warn(38, firstLink);\n      return firstLink;\n    }\n\n    var nextLink = toLink(second);\n    var ret;\n\n    if (isTerminating(nextLink)) {\n      ret = new ApolloLink(function (operation) {\n        return firstLink.request(operation, function (op) {\n          return nextLink.request(op) || Observable.of();\n        }) || Observable.of();\n      });\n    } else {\n      ret = new ApolloLink(function (operation, forward) {\n        return firstLink.request(operation, function (op) {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of();\n      });\n    }\n\n    return Object.assign(ret, {\n      left: firstLink,\n      right: nextLink\n    });\n  };\n\n  ApolloLink.prototype.split = function (test, left, right) {\n    return this.concat(ApolloLink.split(test, left, right || new ApolloLink(passthrough)));\n  };\n\n  ApolloLink.prototype.concat = function (next) {\n    return ApolloLink.concat(this, next);\n  };\n\n  ApolloLink.prototype.request = function (operation, forward) {\n    throw newInvariantError(39);\n  };\n\n  ApolloLink.prototype.onError = function (error, observer) {\n    if (observer && observer.error) {\n      observer.error(error); // Returning false indicates that observer.error does not need to be\n      // called again, since it was already called (on the previous line).\n      // Calling observer.error again would not cause any real problems,\n      // since only the first call matters, but custom onError functions\n      // might have other reasons for wanting to prevent the default\n      // behavior by returning false.\n\n      return false;\n    } // Throw errors will be passed to observer.error.\n\n\n    throw error;\n  };\n\n  ApolloLink.prototype.setOnError = function (fn) {\n    this.onError = fn;\n    return this;\n  };\n\n  return ApolloLink;\n}();\n\nexport { ApolloLink };","map":{"version":3,"mappings":"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","names":["newInvariantError","invariant","Observable","validateOperation","createOperation","transformOperation","passthrough","op","forward","of","toLink","handler","ApolloLink","isTerminating","link","request","length","links","empty","map","reduce","x","y","concat","test","left","right","leftLink","rightLink","ret","operation","Object","assign","context","first","second","firstLink","globalThis","nextLink","split","next","error","observer","fn","onError"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/link/core/ApolloLink.ts"],"sourcesContent":["import { newInvariantError, invariant } from \"../../utilities/globals/index.js\";\n\nimport type { Observer } from \"../../utilities/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport type {\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n  GraphQLRequest,\n} from \"./types.js\";\nimport {\n  validateOperation,\n  createOperation,\n  transformOperation,\n} from \"../utils/index.js\";\n\nfunction passthrough(op: Operation, forward: NextLink) {\n  return (forward ? forward(op) : Observable.of()) as Observable<FetchResult>;\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === \"function\" ? new ApolloLink(handler) : handler;\n}\n\nfunction isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport class ApolloLink {\n  public static empty(): ApolloLink {\n    return new ApolloLink(() => Observable.of());\n  }\n\n  public static from(links: (ApolloLink | RequestHandler)[]): ApolloLink {\n    if (links.length === 0) return ApolloLink.empty();\n    return links.map(toLink).reduce((x, y) => x.concat(y)) as ApolloLink;\n  }\n\n  public static split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler\n  ): ApolloLink {\n    const leftLink = toLink(left);\n    const rightLink = toLink(right || new ApolloLink(passthrough));\n\n    let ret: ApolloLink;\n    if (isTerminating(leftLink) && isTerminating(rightLink)) {\n      ret = new ApolloLink((operation) => {\n        return test(operation) ?\n            leftLink.request(operation) || Observable.of()\n          : rightLink.request(operation) || Observable.of();\n      });\n    } else {\n      ret = new ApolloLink((operation, forward) => {\n        return test(operation) ?\n            leftLink.request(operation, forward) || Observable.of()\n          : rightLink.request(operation, forward) || Observable.of();\n      });\n    }\n    return Object.assign(ret, { left: leftLink, right: rightLink });\n  }\n\n  public static execute(\n    link: ApolloLink,\n    operation: GraphQLRequest\n  ): Observable<FetchResult> {\n    return (\n      link.request(\n        createOperation(\n          operation.context,\n          transformOperation(validateOperation(operation))\n        )\n      ) || Observable.of()\n    );\n  }\n\n  public static concat(\n    first: ApolloLink | RequestHandler,\n    second: ApolloLink | RequestHandler\n  ) {\n    const firstLink = toLink(first);\n    if (isTerminating(firstLink)) {\n      invariant.warn(\n        `You are calling concat on a terminating link, which will have no effect %o`,\n        firstLink\n      );\n      return firstLink;\n    }\n    const nextLink = toLink(second);\n\n    let ret: ApolloLink;\n    if (isTerminating(nextLink)) {\n      ret = new ApolloLink(\n        (operation) =>\n          firstLink.request(\n            operation,\n            (op) => nextLink.request(op) || Observable.of()\n          ) || Observable.of()\n      );\n    } else {\n      ret = new ApolloLink((operation, forward) => {\n        return (\n          firstLink.request(operation, (op) => {\n            return nextLink.request(op, forward) || Observable.of();\n          }) || Observable.of()\n        );\n      });\n    }\n    return Object.assign(ret, { left: firstLink, right: nextLink });\n  }\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler\n  ): ApolloLink {\n    return this.concat(\n      ApolloLink.split(test, left, right || new ApolloLink(passthrough))\n    );\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return ApolloLink.concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink\n  ): Observable<FetchResult> | null {\n    throw newInvariantError(\"request is not implemented\");\n  }\n\n  protected onError(\n    error: any,\n    observer?: Observer<FetchResult>\n  ): false | void {\n    if (observer && observer.error) {\n      observer.error(error);\n      // Returning false indicates that observer.error does not need to be\n      // called again, since it was already called (on the previous line).\n      // Calling observer.error again would not cause any real problems,\n      // since only the first call matters, but custom onError functions\n      // might have other reasons for wanting to prevent the default\n      // behavior by returning false.\n      return false;\n    }\n    // Throw errors will be passed to observer.error.\n    throw error;\n  }\n\n  public setOnError(fn: ApolloLink[\"onError\"]): this {\n    this.onError = fn;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all links that are concatenations or `split` links.\n   */\n  readonly left?: ApolloLink;\n  /**\n   * @internal\n   * Used to iterate through all links that are concatenations or `split` links.\n   */\n  readonly right?: ApolloLink;\n\n  /**\n   * @internal\n   * Can be provided by a link that has an internal cache to report it's memory details.\n   */\n  getMemoryInternals?: () => unknown;\n}\n"]},"metadata":{},"sourceType":"module"}