{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { createMakeWatchQueryOptions, getDefaultFetchPolicy, getObsQueryOptions, toQueryResult, useQueryInternals } from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\"; // The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\n\nvar EAGER_METHODS = [\"refetch\", \"reobserve\", \"fetchMore\", \"updateQuery\", \"startPolling\", \"stopPolling\", \"subscribeToMore\"];\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLazyQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(\n *     GET_GREETING,\n *     { variables: { language: \"english\" } }\n *   );\n *   if (called && loading) return <p>Loading ...</p>\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\n\nexport function useLazyQuery(query, options) {\n  var _a;\n\n  var execOptionsRef = React.useRef(void 0);\n  var optionsRef = React.useRef(void 0);\n  var queryRef = React.useRef(void 0);\n  var merged = mergeOptions(options, execOptionsRef.current || {});\n  var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query; // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n\n  optionsRef.current = options;\n  queryRef.current = document;\n\n  var queryHookOptions = __assign(__assign({}, merged), {\n    skip: !execOptionsRef.current\n  });\n\n  var _b = useQueryInternals(document, queryHookOptions),\n      obsQueryFields = _b.obsQueryFields,\n      useQueryResult = _b.result,\n      client = _b.client,\n      resultData = _b.resultData,\n      observable = _b.observable,\n      onQueryExecuted = _b.onQueryExecuted;\n\n  var initialFetchPolicy = observable.options.initialFetchPolicy || getDefaultFetchPolicy(queryHookOptions.defaultOptions, client.defaultOptions);\n  var forceUpdateState = React.useReducer(function (tick) {\n    return tick + 1;\n  }, 0)[1]; // We use useMemo here to make sure the eager methods have a stable identity.\n\n  var eagerMethods = React.useMemo(function () {\n    var eagerMethods = {};\n\n    var _loop_1 = function (key) {\n      var method = obsQueryFields[key];\n\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null); // Only the first time populating execOptionsRef.current matters here.\n\n          forceUpdateState();\n        } // @ts-expect-error this is just too generic to type\n\n\n        return method.apply(this, arguments);\n      };\n    };\n\n    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n      var key = EAGER_METHODS_1[_i];\n\n      _loop_1(key);\n    }\n\n    return eagerMethods;\n  }, [forceUpdateState, obsQueryFields]);\n  var called = !!execOptionsRef.current;\n  var result = React.useMemo(function () {\n    return __assign(__assign(__assign({}, useQueryResult), eagerMethods), {\n      called: called\n    });\n  }, [useQueryResult, eagerMethods, called]);\n  var execute = React.useCallback(function (executeOptions) {\n    execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), {\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy\n    }) : {\n      fetchPolicy: initialFetchPolicy\n    };\n    var options = mergeOptions(optionsRef.current, __assign({\n      query: queryRef.current\n    }, execOptionsRef.current));\n    var promise = executeQuery(resultData, observable, client, document, __assign(__assign({}, options), {\n      skip: false\n    }), onQueryExecuted).then(function (queryResult) {\n      return Object.assign(queryResult, eagerMethods);\n    }); // Because the return value of `useLazyQuery` is usually floated, we need\n    // to catch the promise to prevent unhandled rejections.\n\n    promise.catch(function () {});\n    return promise;\n  }, [client, document, eagerMethods, initialFetchPolicy, observable, resultData, onQueryExecuted]);\n  var executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(function () {\n    executeRef.current = execute;\n  });\n  var stableExecute = React.useCallback(function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return executeRef.current.apply(executeRef, args);\n  }, []);\n  return [stableExecute, result];\n}\n\nfunction executeQuery(resultData, observable, client, currentQuery, options, onQueryExecuted) {\n  var query = options.query || currentQuery;\n  var watchQueryOptions = createMakeWatchQueryOptions(client, query, options, false)(observable);\n  var concast = observable.reobserveAsConcast(getObsQueryOptions(observable, client, options, watchQueryOptions));\n  onQueryExecuted(watchQueryOptions);\n  return new Promise(function (resolve) {\n    var result; // Subscribe to the concast independently of the ObservableQuery in case\n    // the component gets unmounted before the promise resolves. This prevents\n    // the concast from terminating early and resolving with `undefined` when\n    // there are no more subscribers for the concast.\n\n    concast.subscribe({\n      next: function (value) {\n        result = value;\n      },\n      error: function () {\n        resolve(toQueryResult(observable.getCurrentResult(), resultData.previousData, observable, client));\n      },\n      complete: function () {\n        resolve(toQueryResult(observable[\"maskResult\"](result), resultData.previousData, observable, client));\n      }\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["React","mergeOptions","createMakeWatchQueryOptions","getDefaultFetchPolicy","getObsQueryOptions","toQueryResult","useQueryInternals","useIsomorphicLayoutEffect","EAGER_METHODS","useLazyQuery","query","options","execOptionsRef","useRef","optionsRef","queryRef","merged","current","document","_a","queryHookOptions","skip","obsQueryFields","useQueryResult","client","resultData","observable","onQueryExecuted","initialFetchPolicy","defaultOptions","forceUpdateState","useReducer","tick","eagerMethods","useMemo","key","method","Object","create","apply","arguments","_i","called","result","execute","useCallback","executeOptions","__assign","fetchPolicy","promise","executeQuery","then","queryResult","assign","catch","executeRef","stableExecute","args","currentQuery","watchQueryOptions","concast","reobserveAsConcast","Promise","resolve","subscribe","next","value","error","getCurrentResult","previousData","complete"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/react/hooks/useLazyQuery.ts"],"sourcesContent":["import type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport * as React from \"rehackt\";\n\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type {\n  LazyQueryHookExecOptions,\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  NoInfer,\n  QueryHookOptions,\n  QueryResult,\n} from \"../types/types.js\";\nimport type { InternalResult, ObsQueryWithMeta } from \"./useQuery.js\";\nimport {\n  createMakeWatchQueryOptions,\n  getDefaultFetchPolicy,\n  getObsQueryOptions,\n  toQueryResult,\n  useQueryInternals,\n} from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"reobserve\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"stopPolling\",\n  \"subscribeToMore\",\n] as const;\n\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLazyQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(\n *     GET_GREETING,\n *     { variables: { language: \"english\" } }\n *   );\n *   if (called && loading) return <p>Loading ...</p>\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef =\n    React.useRef<Partial<LazyQueryHookExecOptions<TData, TVariables>>>(void 0);\n  const optionsRef =\n    React.useRef<LazyQueryHookOptions<TData, TVariables>>(void 0);\n  const queryRef = React.useRef<\n    DocumentNode | TypedDocumentNode<TData, TVariables>\n  >(void 0);\n  const merged = mergeOptions(options, execOptionsRef.current || {});\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = options;\n  queryRef.current = document;\n\n  const queryHookOptions = {\n    ...merged,\n    skip: !execOptionsRef.current,\n  };\n  const {\n    obsQueryFields,\n    result: useQueryResult,\n    client,\n    resultData,\n    observable,\n    onQueryExecuted,\n  } = useQueryInternals(document, queryHookOptions);\n\n  const initialFetchPolicy =\n    observable.options.initialFetchPolicy ||\n    getDefaultFetchPolicy(\n      queryHookOptions.defaultOptions,\n      client.defaultOptions\n    );\n\n  const forceUpdateState = React.useReducer((tick) => tick + 1, 0)[1];\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = obsQueryFields[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          forceUpdateState();\n        }\n        // @ts-expect-error this is just too generic to type\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods as typeof obsQueryFields;\n  }, [forceUpdateState, obsQueryFields]);\n\n  const called = !!execOptionsRef.current;\n  const result = React.useMemo(\n    () => ({\n      ...useQueryResult,\n      ...eagerMethods,\n      called,\n    }),\n    [useQueryResult, eagerMethods, called]\n  );\n\n  const execute = React.useCallback<LazyQueryResultTuple<TData, TVariables>[0]>(\n    (executeOptions) => {\n      execOptionsRef.current =\n        executeOptions ?\n          {\n            ...executeOptions,\n            fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n          }\n        : {\n            fetchPolicy: initialFetchPolicy,\n          };\n\n      const options = mergeOptions(optionsRef.current, {\n        query: queryRef.current,\n        ...execOptionsRef.current,\n      });\n\n      const promise = executeQuery(\n        resultData,\n        observable,\n        client,\n        document,\n        { ...options, skip: false },\n        onQueryExecuted\n      ).then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n      // Because the return value of `useLazyQuery` is usually floated, we need\n      // to catch the promise to prevent unhandled rejections.\n      promise.catch(() => {});\n\n      return promise;\n    },\n    [\n      client,\n      document,\n      eagerMethods,\n      initialFetchPolicy,\n      observable,\n      resultData,\n      onQueryExecuted,\n    ]\n  );\n\n  const executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(() => {\n    executeRef.current = execute;\n  });\n\n  const stableExecute = React.useCallback<typeof execute>(\n    (...args) => executeRef.current(...args),\n    []\n  );\n  return [stableExecute, result];\n}\n\nfunction executeQuery<TData, TVariables extends OperationVariables>(\n  resultData: InternalResult<TData, TVariables>,\n  observable: ObsQueryWithMeta<TData, TVariables>,\n  client: ApolloClient<object>,\n  currentQuery: DocumentNode,\n  options: QueryHookOptions<TData, TVariables> & {\n    query?: DocumentNode;\n  },\n  onQueryExecuted: (options: WatchQueryOptions<TVariables, TData>) => void\n) {\n  const query = options.query || currentQuery;\n  const watchQueryOptions = createMakeWatchQueryOptions(\n    client,\n    query,\n    options,\n    false\n  )(observable);\n\n  const concast = observable.reobserveAsConcast(\n    getObsQueryOptions(observable, client, options, watchQueryOptions)\n  );\n  onQueryExecuted(watchQueryOptions);\n\n  return new Promise<\n    Omit<QueryResult<TData, TVariables>, (typeof EAGER_METHODS)[number]>\n  >((resolve) => {\n    let result: ApolloQueryResult<TData>;\n\n    // Subscribe to the concast independently of the ObservableQuery in case\n    // the component gets unmounted before the promise resolves. This prevents\n    // the concast from terminating early and resolving with `undefined` when\n    // there are no more subscribers for the concast.\n    concast.subscribe({\n      next: (value) => {\n        result = value;\n      },\n      error: () => {\n        resolve(\n          toQueryResult(\n            observable.getCurrentResult(),\n            resultData.previousData,\n            observable,\n            client\n          )\n        );\n      },\n      complete: () => {\n        resolve(\n          toQueryResult(\n            observable[\"maskResult\"](result),\n            resultData.previousData,\n            observable,\n            client\n          )\n        );\n      },\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}