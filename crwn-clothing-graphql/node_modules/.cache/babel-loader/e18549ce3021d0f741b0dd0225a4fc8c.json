{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { isField, resultKeyNameFromField, isReference, makeReference, shouldInclude, addTypenameToDocument, getDefaultValues, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, canonicalStringify, cacheSizes } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\n\nfunction execSelectionSetKeyArgs(options) {\n  return [options.selectionSet, options.objectOrReference, options.context, // We split out this property so we can pass different values\n  // independently without modifying options.context itself.\n  options.context.canonizeResults];\n}\n\nvar StoreReader =\n/** @class */\nfunction () {\n  function StoreReader(config) {\n    var _this = this;\n\n    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config)\n    });\n    this.canon = config.canon || new ObjectCanon(); // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n\n    this.executeSelectionSet = wrap(function (options) {\n      var _a;\n\n      var canonizeResults = options.context.canonizeResults;\n      var peekArgs = execSelectionSetKeyArgs(options); // Negate this boolean option so we can find out if we've already read\n      // this result using the other boolean value.\n\n      peekArgs[3] = !canonizeResults;\n\n      var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n\n      if (other) {\n        if (canonizeResults) {\n          return __assign(__assign({}, other), {\n            // If we previously read this result without canonizing it, we can\n            // reuse that result simply by canonizing it now.\n            result: _this.canon.admit(other.result)\n          });\n        } // If we previously read this result with canonization enabled, we can\n        // return that canonized result as-is.\n\n\n        return other;\n      }\n\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref); // Finally, if we didn't find any useful previous results, run the real\n      // execSelectionSetImpl method with the given options.\n\n      return _this.execSelectionSetImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSelectionSet\"] || 50000\n      /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */\n      ,\n      keyArgs: execSelectionSetKeyArgs,\n      // Note that the parameters of makeCacheKey are determined by the\n      // array returned by keyArgs.\n      makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n        }\n      }\n    });\n    this.executeSubSelectedArray = wrap(function (options) {\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] || 10000\n      /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */\n      ,\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n            array = _a.array,\n            context = _a.context;\n\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n  }\n\n  StoreReader.prototype.resetCanon = function () {\n    this.canon = new ObjectCanon();\n  };\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n\n\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n        query = _a.query,\n        _b = _a.rootId,\n        rootId = _b === void 0 ? \"ROOT_QUERY\" : _b,\n        variables = _a.variables,\n        _c = _a.returnPartialData,\n        returnPartialData = _c === void 0 ? true : _c,\n        _d = _a.canonizeResults,\n        canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n    var policies = this.config.cache.policies;\n    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n    var rootRef = makeReference(rootId);\n    var execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: __assign({\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: canonicalStringify(variables),\n        canonizeResults: canonizeResults\n      }, extractFragmentContext(query, this.config.fragments))\n    });\n    var missing;\n\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];\n\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing: missing\n    };\n  };\n\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context, // If result is canonical, then it could only have been previously\n      // cached by the canonizing version of executeSelectionSet, so we can\n      // avoid checking both possibilities here.\n      this.canon.isKnown(result));\n\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // Uncached version of executeSelectionSet.\n\n\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n\n    var selectionSet = _a.selectionSet,\n        objectOrReference = _a.objectOrReference,\n        enclosingRef = _a.enclosingRef,\n        context = _a.context;\n\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\")\n      };\n    }\n\n    var variables = context.variables,\n        policies = context.policies,\n        store = context.store;\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n    var objectsToMerge = [];\n    var missing;\n    var missingMerger = new DeepMerger();\n\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n\n    function handleMissing(result, resultName) {\n      var _a;\n\n      if (result.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));\n      }\n\n      return result.result;\n    }\n\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a, _b; // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n\n\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2)), _a));\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(_this.executeSubSelectedArray({\n              field: selection,\n              array: fieldValue,\n              enclosingRef: enclosingRef,\n              context: context\n            }), resultName);\n          }\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = _this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context: context\n          }), resultName);\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(10, selection.name.value);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    var result = mergeDeepArray(objectsToMerge);\n    var finalResult = {\n      result: result,\n      missing: missing\n    };\n    var frozen = context.canonizeResults ? this.canon.admit(finalResult) // Since this.canon is normally responsible for freezing results (only in\n    // development), freeze them manually if canonization is disabled.\n    : maybeDeepFreeze(finalResult); // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }; // Uncached version of executeSubSelectedArray.\n\n\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n\n    var field = _a.field,\n        array = _a.array,\n        enclosingRef = _a.enclosingRef,\n        context = _a.context;\n    var missing;\n    var missingMerger = new DeepMerger();\n\n    function handleMissing(childResult, i) {\n      var _a;\n\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n      }\n\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map(function (item, i) {\n      // null value in array\n      if (item === null) {\n        return null;\n      } // This is a nested array, recurse\n\n\n      if (isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          enclosingRef: enclosingRef,\n          context: context\n        }), i);\n      } // This is an object, run the selection set on it\n\n\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context: context\n        }), i);\n      }\n\n      if (globalThis.__DEV__ !== false) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing: missing\n    };\n  };\n\n  return StoreReader;\n}();\n\nexport { StoreReader };\n\nfunction firstMissing(tree) {\n  try {\n    JSON.stringify(tree, function (_, value) {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\n\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if (isNonNullObject(value)) {\n        invariant(!isReference(value), 11, getTypenameFromStoreObject(store, value), field.name.value);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["invariant","newInvariantError","Kind","wrap","isField","resultKeyNameFromField","isReference","makeReference","shouldInclude","addTypenameToDocument","getDefaultValues","getMainDefinition","getQueryDefinition","getFragmentFromSelection","maybeDeepFreeze","mergeDeepArray","DeepMerger","isNonNullObject","canUseWeakMap","compact","canonicalStringify","cacheSizes","maybeDependOnExistenceOfEntity","supportsResultCaching","isArray","extractFragmentContext","getTypenameFromStoreObject","shouldCanonizeResults","MissingFieldError","ObjectCanon","execSelectionSetKeyArgs","options","selectionSet","objectOrReference","context","canonizeResults","config","WeakMap","Map","addTypename","canon","executeSelectionSet","peekArgs","other","peek","apply","_a","result","_this","admit","store","enclosingRef","__ref","execSelectionSetImpl","max","resultCacheMaxSize","keyArgs","makeCacheKey","parent","varString","executeSubSelectedArray","execSubSelectedArrayImpl","field","array","StoreReader","query","_b","rootId","variables","_c","returnPartialData","_d","policies","cache","rootRef","execResult","fragments","missing","firstMissing","complete","knownResults","get","latest","isKnown","rootTypenamesById","has","empty","typename","getFieldValue","objectsToMerge","missingMerger","rootIdsByTypename","push","__typename","handleMissing","resultName","merge","workSet","Set","selections","forEach","selection","fieldValue","readField","fieldName","name","value","from","added","concat","JSON","stringify","length","pass","fragment","lookupFragment","kind","FRAGMENT_SPREAD","fragmentMatches","add","finalResult","frozen","set","childResult","i","filter","canRead","map","item","globalThis","assertSelectionSetForIdValue","tree","_","workSet_1"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/cache/inmemory/readFromStore.ts"],"sourcesContent":["import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type {\n  Reference,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  makeReference,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getMainDefinition,\n  getQueryDefinition,\n  getFragmentFromSelection,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  DeepMerger,\n  isNonNullObject,\n  canUseWeakMap,\n  compact,\n  canonicalStringify,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  DiffQueryAgainstStoreOptions,\n  InMemoryCacheConfig,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  maybeDependOnExistenceOfEntity,\n  supportsResultCaching,\n} from \"./entityStore.js\";\nimport {\n  isArray,\n  extractFragmentContext,\n  getTypenameFromStoreObject,\n  shouldCanonizeResults,\n} from \"./helpers.js\";\nimport type { Policies } from \"./policies.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { MissingTree } from \"../core/types/common.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  canonizeResults: boolean;\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n}\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingTree;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: readonly any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache;\n  addTypename?: boolean;\n  resultCacheMaxSize?: number;\n  canonizeResults?: boolean;\n  canon?: ObjectCanon;\n  fragments?: InMemoryCacheConfig[\"fragments\"];\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n  boolean,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions\n): ExecSelectionSetKeyArgs {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults,\n  ];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]\n  >;\n\n  private config: {\n    cache: InMemoryCache;\n    addTypename: boolean;\n    resultCacheMaxSize?: number;\n    canonizeResults: boolean;\n    fragments?: InMemoryCacheConfig[\"fragments\"];\n  };\n\n  private knownResults = new (canUseWeakMap ? WeakMap : Map)<\n    Record<string, any>,\n    SelectionSetNode\n  >();\n\n  public canon: ObjectCanon;\n  public resetCanon() {\n    this.canon = new ObjectCanon();\n  }\n\n  constructor(config: StoreReaderConfig) {\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config),\n    });\n\n    this.canon = config.canon || new ObjectCanon();\n\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(\n      (options) => {\n        const { canonizeResults } = options.context;\n\n        const peekArgs = execSelectionSetKeyArgs(options);\n\n        // Negate this boolean option so we can find out if we've already read\n        // this result using the other boolean value.\n        peekArgs[3] = !canonizeResults;\n\n        const other = this.executeSelectionSet.peek(...peekArgs);\n\n        if (other) {\n          if (canonizeResults) {\n            return {\n              ...other,\n              // If we previously read this result without canonizing it, we can\n              // reuse that result simply by canonizing it now.\n              result: this.canon.admit(other.result),\n            };\n          }\n          // If we previously read this result with canonization enabled, we can\n          // return that canonized result as-is.\n          return other;\n        }\n\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n\n        // Finally, if we didn't find any useful previous results, run the real\n        // execSelectionSetImpl method with the given options.\n        return this.execSelectionSetImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"],\n        keyArgs: execSelectionSetKeyArgs,\n        // Note that the parameters of makeCacheKey are determined by the\n        // array returned by keyArgs.\n        makeCacheKey(selectionSet, parent, context, canonizeResults) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(\n              selectionSet,\n              isReference(parent) ? parent.__ref : parent,\n              context.varString,\n              canonizeResults\n            );\n          }\n        },\n      }\n    );\n\n    this.executeSubSelectedArray = wrap(\n      (options: ExecSubSelectedArrayOptions) => {\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n        return this.execSubSelectedArrayImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"],\n        makeCacheKey({ field, array, context }) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(field, array, context.varString);\n          }\n        },\n      }\n    );\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = \"ROOT_QUERY\",\n    variables,\n    returnPartialData = true,\n    canonizeResults = this.config.canonizeResults,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        canonizeResults,\n        ...extractFragmentContext(query, this.config.fragments),\n      },\n    });\n\n    let missing: MissingFieldError[] | undefined;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [\n        new MissingFieldError(\n          firstMissing(execResult.missing)!,\n          execResult.missing,\n          query,\n          variables\n        ),\n      ];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext\n  ): boolean {\n    if (\n      supportsResultCaching(context.store) &&\n      this.knownResults.get(result) === selectionSet\n    ) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context,\n        // If result is canonical, then it could only have been previously\n        // cached by the canonizing version of executeSelectionSet, so we can\n        // avoid checking both possibilities here.\n        this.canon.isKnown(result)\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (\n      isReference(objectOrReference) &&\n      !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n      !context.store.has(objectOrReference.__ref)\n    ) {\n      return {\n        result: this.canon.empty,\n        missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const typename = store.getFieldValue<string>(\n      objectOrReference,\n      \"__typename\"\n    );\n\n    const objectsToMerge: Record<string, any>[] = [];\n    let missing: MissingTree | undefined;\n    const missingMerger = new DeepMerger();\n\n    if (\n      this.config.addTypename &&\n      typeof typename === \"string\" &&\n      !policies.rootIdsByTypename[typename]\n    ) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function handleMissing<T>(result: ExecResult<T>, resultName: string): T {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, {\n          [resultName]: result.missing,\n        });\n      }\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach((selection) => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField(\n          {\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n            from: objectOrReference,\n          },\n          context\n        );\n\n        const resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: `Can't find field '${selection.name.value}' on ${\n                isReference(objectOrReference) ?\n                  objectOrReference.__ref + \" object\"\n                : \"object \" + JSON.stringify(objectOrReference, null, 2)\n              }`,\n            });\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(\n              this.executeSubSelectedArray({\n                field: selection,\n                array: fieldValue,\n                enclosingRef,\n                context,\n              }),\n              resultName\n            );\n          }\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(\n            this.executeSelectionSet({\n              selectionSet: selection.selectionSet,\n              objectOrReference: fieldValue as StoreObject | Reference,\n              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.lookupFragment\n        );\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(`No fragment named %s`, selection.name.value);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult: ExecResult = { result, missing };\n    const frozen =\n      context.canonizeResults ?\n        this.canon.admit(finalResult)\n        // Since this.canon is normally responsible for freezing results (only in\n        // development), freeze them manually if canonization is disabled.\n      : maybeDeepFreeze(finalResult);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingTree | undefined;\n    let missingMerger = new DeepMerger<MissingTree[]>();\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, { [i]: childResult.missing });\n      }\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(\n          this.executeSubSelectedArray({\n            field,\n            array: item,\n            enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(\n          this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            objectOrReference: item,\n            enclosingRef: isReference(item) ? item : enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing,\n    };\n  }\n}\n\nfunction firstMissing(tree: MissingTree): string | undefined {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result as string;\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach((value) => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type %s returned for query field %s`,\n          getTypenameFromStoreObject(store, value),\n          field.name.value\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}