{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\nimport { disableWarningsSlot } from \"../../masking/index.js\";\n\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\n\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n}; // These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\n\n\nvar mergeTrueFn = function (existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\n\nvar mergeFalseFn = function (_, incoming) {\n  return incoming;\n};\n\nvar Policies =\n/** @class */\nfunction () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.toBeAdded = Object.create(null); // Map from subtype names to sets of supertype names. Note that this\n    // representation inverts the structure of possibleTypes (whose keys are\n    // supertypes and whose values are arrays of subtypes) because it tends\n    // to be much more efficient to search upwards than downwards.\n\n    this.supertypeMap = new Map(); // Any fuzzy subtypes specified by possibleTypes will be converted to\n    // RegExp objects and recorded here. Every key of this map can also be\n    // found in supertypeMap. In many cases this Map will be empty, which\n    // means no fuzzy subtype checking will happen in fragmentMatches.\n\n    this.fuzzySubtypes = new Map();\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  Policies.prototype.identify = function (object, partialContext) {\n    var _a;\n\n    var policies = this;\n    var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename; // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    } // Default context.storeObject to object if not otherwise provided.\n\n\n    var storeObject = partialContext && partialContext.storeObject || object;\n\n    var context = __assign(__assign({}, partialContext), {\n      typename: typename,\n      storeObject: storeObject,\n      readField: partialContext && partialContext.readField || function () {\n        var options = normalizeReadFieldOptions(arguments, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables\n        });\n      }\n    });\n\n    var id;\n    var policy = typename && this.getTypePolicy(typename);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    disableWarningsSlot.withValue(true, function () {\n      while (keyFn) {\n        var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\n\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n\n    Object.keys(typePolicies).forEach(function (typename) {\n      var _a = typePolicies[typename],\n          queryType = _a.queryType,\n          mutationType = _a.mutationType,\n          subscriptionType = _a.subscriptionType,\n          incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]); // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n\n\n      if (queryType) _this.setRootTypename(\"Query\", typename);\n      if (mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(_this.toBeAdded, typename)) {\n        _this.toBeAdded[typename].push(incoming);\n      } else {\n        _this.toBeAdded[typename] = [incoming];\n      }\n    });\n  };\n\n  Policies.prototype.updateTypePolicy = function (typename, incoming) {\n    var _this = this;\n\n    var existing = this.getTypePolicy(typename);\n    var keyFields = incoming.keyFields,\n        fields = incoming.fields;\n\n    function setMerge(existing, merge) {\n      existing.merge = typeof merge === \"function\" ? merge // Pass merge:true as a shorthand for a merge implementation\n      // that returns options.mergeObjects(existing, incoming).\n      : merge === true ? mergeTrueFn // Pass merge:false to make incoming always replace existing\n      // without any warnings about data clobbering.\n      : merge === false ? mergeFalseFn : existing.merge;\n    } // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n\n\n    setMerge(existing, incoming.merge);\n    existing.keyFn = // Pass false to disable normalization for this typename.\n    keyFields === false ? nullKeyFieldsFn // Pass an array of strings to use those fields to compute a\n    // composite ID for objects of this typename.\n    : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) // Pass a function to take full control over identification.\n    : typeof keyFields === \"function\" ? keyFields // Leave existing.keyFn unchanged if above cases fail.\n    : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach(function (fieldName) {\n        var existing = _this.getFieldPolicy(typename, fieldName, true);\n\n        var incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          var keyArgs = incoming.keyArgs,\n              read = incoming.read,\n              merge = incoming.merge;\n          existing.keyFn = // Pass false to disable argument-based differentiation of\n          // field identities.\n          keyArgs === false ? simpleKeyArgsFn // Pass an array of strings to use named arguments to\n          // compute a composite identity for the field.\n          : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) // Pass a function to take full control over field identity.\n          : typeof keyArgs === \"function\" ? keyArgs // Leave existing.keyFn unchanged if above cases fail.\n          : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  };\n\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n\n    if (typename !== old) {\n      invariant(!old || old === which, 6, which); // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n\n      if (old) delete this.rootIdsByTypename[old]; // Now make this the only __typename that maps to this rootId.\n\n      this.rootIdsByTypename[typename] = rootId; // Finally, update the __typename associated with this rootId.\n\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      _this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(function (subtype) {\n        _this.getSupertypeSet(subtype, true).add(supertype);\n\n        var match = subtype.match(TypeOrFieldNameRegExp);\n\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  };\n\n  Policies.prototype.getTypePolicy = function (typename) {\n    var _this = this;\n\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      var policy_1 = this.typePolicies[typename] = Object.create(null);\n      policy_1.fields = Object.create(null); // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n\n      var supertypes_1 = this.supertypeMap.get(typename);\n\n      if (!supertypes_1 && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes_1 = this.getSupertypeSet(typename, true); // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n\n        this.fuzzySubtypes.forEach(function (regExp, fuzzy) {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\n\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach(function (supertype) {\n                return supertypes_1.add(supertype);\n              });\n            }\n          }\n        });\n      }\n\n      if (supertypes_1 && supertypes_1.size) {\n        supertypes_1.forEach(function (supertype) {\n          var _a = _this.getTypePolicy(supertype),\n              fields = _a.fields,\n              rest = __rest(_a, [\"fields\"]);\n\n          Object.assign(policy_1, rest);\n          Object.assign(policy_1.fields, fields);\n        });\n      }\n    }\n\n    var inbox = this.toBeAdded[typename];\n\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach(function (policy) {\n        _this.updateTypePolicy(typename, policy);\n      });\n    }\n\n    return this.typePolicies[typename];\n  };\n\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    if (typename) {\n      var fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n    }\n  };\n\n  Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n    var supertypeSet = this.supertypeMap.get(subtype);\n\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set());\n    }\n\n    return supertypeSet;\n  };\n\n  Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n    var _this = this;\n\n    if (!fragment.typeCondition) return true; // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value; // Common case: fragment type condition and __typename are the same.\n\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n      var workQueue_1 = [typenameSupertypeSet];\n\n      var maybeEnqueue_1 = function (subtype) {\n        var supertypeSet = _this.getSupertypeSet(subtype, false);\n\n        if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {\n          workQueue_1.push(supertypeSet);\n        }\n      }; // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n\n\n      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      var checkingFuzzySubtypes = false; // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var supertypeSet = workQueue_1[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              globalThis.__DEV__ !== false && invariant.warn(7, typename, supertype);\n            } // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n\n\n            typenameSupertypeSet.add(supertype);\n          }\n\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue_1);\n\n        if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all\n        // non-fuzzy subtypes (after the final iteration of the loop).\n        i === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result\n        // after we verify the supertype, but this check is often less\n        // expensive than that search, and we will have to do the\n        // comparison anyway whenever we find a potential match.\n        selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true; // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n\n          this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n            var match = typename.match(regExp);\n\n            if (match && match[0] === typename) {\n              maybeEnqueue_1(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  };\n\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n        fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    } // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n\n\n    if (storeFieldName === false) {\n      return fieldName;\n    } // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n\n\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n\n    if (read) {\n      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName)); // Call read(existing, readOptions) with cacheSlot holding this.cache.\n\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n\n    return existing;\n  };\n\n  Policies.prototype.getReadFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  };\n\n  Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n    var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n    var merge = policy && policy.merge;\n\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n\n    return merge;\n  };\n\n  Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n    var field = _a.field,\n        typename = _a.typename,\n        merge = _a.merge;\n\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(existing, incoming);\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    } // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n\n\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(existing, incoming, makeFieldFunctionOptions(this, // Unlike options.readField for read functions, we do not fall\n    // back to the current object if no foreignObjOrRef is provided,\n    // because it's not clear what the current object should be for\n    // merge functions: the (possibly undefined) existing object, or\n    // the incoming object? If you think your merge function needs\n    // to read sibling fields in order to produce a new value for\n    // the current field, you might want to rethink your strategy,\n    // because that's a recipe for making merge behavior sensitive\n    // to the order in which fields are written into the cache.\n    // However, readField(name, ref) is useful for merge functions\n    // that need to deduplicate child objects and references.\n    void 0, {\n      typename: typename,\n      fieldName: field.name.value,\n      field: field,\n      variables: context.variables\n    }, context, storage || Object.create(null)));\n  };\n\n  return Policies;\n}();\n\nexport { Policies };\n\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store,\n      toReference = _a.toReference,\n      canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: canRead,\n    readField: function () {\n      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store)\n  };\n}\n\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n  var fieldNameOrOptions = readFieldArgs[0],\n      from = readFieldArgs[1],\n      argc = readFieldArgs.length;\n  var options;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference\n    };\n  } else {\n    options = __assign({}, fieldNameOrOptions); // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (globalThis.__DEV__ !== false && options.from === void 0) {\n    globalThis.__DEV__ !== false && invariant.warn(8, stringifyForDisplay(Array.from(readFieldArgs)));\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(store) {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(9);\n    } // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n\n\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      var eType = store.getFieldValue(existing, \"__typename\");\n      var iType = store.getFieldValue(incoming, \"__typename\");\n      var typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {\n        return __assign(__assign({}, existing), incoming);\n      }\n    }\n\n    return incoming;\n  };\n}","map":{"version":3,"mappings":"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","names":["invariant","newInvariantError","storeKeyNameFromField","argumentsObjectFromField","isReference","getStoreKeyName","isNonNullObject","stringifyForDisplay","hasOwn","fieldNameFromStoreName","storeValueIsStoreObject","selectionSetMatchesResult","TypeOrFieldNameRegExp","defaultDataIdFromObject","isArray","cacheSlot","keyArgsFnFromSpecifier","keyFieldsFnFromSpecifier","disableWarningsSlot","argsFromFieldSpecifier","spec","args","field","variables","nullKeyFieldsFn","simpleKeyArgsFn","_args","context","fieldName","mergeTrueFn","existing","incoming","_a","mergeObjects","mergeFalseFn","_","config","Object","create","Map","__assign","dataIdFromObject","cache","setRootTypename","possibleTypes","addPossibleTypes","typePolicies","addTypePolicies","Policies","object","partialContext","policies","typename","storeObject","__typename","rootTypenamesById","ROOT_QUERY","readField","options","normalizeReadFieldOptions","arguments","store","id","policy","getTypePolicy","keyFn","withValue","specifierOrId","String","keyObject","keys","forEach","queryType","mutationType","subscriptionType","_this","call","toBeAdded","push","fields","setMerge","merge","keyFields","getFieldPolicy","read","keyArgs","which","rootId","toUpperCase","old","rootIdsByTypename","usingPossibleTypes","supertype","getSupertypeSet","subtype","add","match","fuzzySubtypes","set","RegExp","policy_1","supertypes_1","supertypeMap","get","size","regExp","fuzzy","test","fuzzySupertypes","rest","assign","inbox","length","splice","updateTypePolicy","createIfMissing","fieldPolicies","supertypeSet","Set","fragment","result","typeCondition","name","value","has","typenameSupertypeSet","workQueue_1","maybeEnqueue_1","indexOf","needToCheckFuzzySubtypes","checkingFuzzySubtypes","i","globalThis","selectionSet","fuzzyString","fieldSpec","storeFieldName","specifierOrString","objectOrReference","from","nameOrField","getFieldValue","getStoreFieldName","readOptions","makeFieldFunctionOptions","getStorage","__ref","parentTypename","childTypename","storage","makeMergeObjectsFunction","overwrite","toReference","canRead","readFieldArgs","fieldNameOrOptions","argc","__DEV__","eType","iType","typesDiffer"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/cache/inmemory/policies.ts"],"sourcesContent":["import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from \"graphql\";\n\nimport type {\n  FragmentMap,\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  storeKeyNameFromField,\n  argumentsObjectFromField,\n  isReference,\n  getStoreKeyName,\n  isNonNullObject,\n  stringifyForDisplay,\n} from \"../../utilities/index.js\";\nimport type {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n  defaultDataIdFromObject,\n  isArray,\n} from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from \"../core/types/common.js\";\nimport type { WriteContext } from \"./writeToStore.js\";\n\nimport {\n  keyArgsFnFromSpecifier,\n  keyFieldsFnFromSpecifier,\n} from \"./key-extractor.js\";\nimport { disableWarningsSlot } from \"../../masking/index.js\";\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n};\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\nexport type KeySpecifier = ReadonlyArray<string | KeySpecifier>;\n\nexport type KeyFieldsContext = {\n  // The __typename of the incoming object, even if the __typename field was\n  // aliased to another name in the raw result object. May be undefined when\n  // dataIdFromObject is called for objects without __typename fields.\n  typename: string | undefined;\n\n  // The object to be identified, after processing to remove aliases and\n  // normalize identifiable child objects with references.\n  storeObject: StoreObject;\n\n  // Handy tool for reading additional fields from context.storeObject, either\n  // readField(\"fieldName\") to read storeObject[fieldName], or readField(\"name\",\n  // objectOrReference) to read from another object or Reference. If you read a\n  // field with a read function, that function will be invoked.\n  readField: ReadFieldFunction;\n\n  // If you are writing a custom keyFields function, and you plan to use the raw\n  // result object passed as the first argument, you may also need access to the\n  // selection set and available fragments for this object, just in case any\n  // fields have aliases. Since this logic is tricky to get right, and these\n  // context properties are not even always provided (for example, they are\n  // omitted when calling cache.identify(object), where object is assumed to be\n  // a StoreObject), we recommend you use context.storeObject (which has already\n  // been de-aliased) and context.readField (which can read from references as\n  // well as objects) instead of the raw result object in your keyFields\n  // functions, or just rely on the internal implementation of keyFields:[...]\n  // syntax to get these details right for you.\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n\n  // Internal. May be set by the KeyFieldsFunction to report fields that were\n  // involved in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true;\n  mutationType?: true;\n  subscriptionType?: true;\n\n  fields?: {\n    [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;\n  };\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  }\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n  // Allows FieldFunctionOptions definition to be overwritten by the\n  // developer\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult, TOptions>;\n  merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return (\n    spec.args !== void 0 ? spec.args\n    : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n    : null\n  );\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T\n) => T;\n\nexport type FieldReadFunction<\n  TExisting = any,\n  TReadResult = TExisting,\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: TOptions\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<\n  TExisting = any,\n  TIncoming = TExisting,\n  // Passing the whole FieldFunctionOptions makes the current definition\n  // independent from its implementation\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: TOptions\n) => SafeReadonly<TExisting>;\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> = (\n  existing,\n  incoming,\n  { mergeObjects }\n) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: {\n          keyFn?: KeyArgsFunction;\n          read?: FieldReadFunction<any>;\n          merge?: FieldMergeFunction<any>;\n        };\n      };\n    };\n  } = Object.create(null);\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> =\n    Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> =\n    Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(\n    private config: {\n      cache: InMemoryCache;\n      dataIdFromObject?: KeyFieldsFunction;\n      possibleTypes?: PossibleTypesMap;\n      typePolicies?: TypePolicies;\n    }\n  ) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    partialContext?: Partial<KeyFieldsContext>\n  ): [string?, StoreObject?] {\n    const policies = this;\n\n    const typename =\n      (partialContext &&\n        (partialContext.typename || partialContext.storeObject?.__typename)) ||\n      object.__typename;\n\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject =\n      (partialContext && partialContext.storeObject) || object;\n\n    const context: KeyFieldsContext = {\n      ...partialContext,\n      typename,\n      storeObject,\n      readField:\n        (partialContext && partialContext.readField) ||\n        function () {\n          const options = normalizeReadFieldOptions(arguments, storeObject);\n          return policies.readField(options, {\n            store: policies.cache[\"data\"],\n            variables: options.variables,\n          });\n        },\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n\n    disableWarningsSlot.withValue(true, () => {\n      while (keyFn) {\n        const specifierOrId = keyFn({ ...object, ...storeObject }, context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach((typename) => {\n      const { queryType, mutationType, subscriptionType, ...incoming } =\n        typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(typename: string, incoming: TypePolicy) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean },\n      merge?: FieldMergeFunction | boolean\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge\n          // Pass merge:true as a shorthand for a merge implementation\n          // that returns options.mergeObjects(existing, incoming).\n        : merge === true ? mergeTrueFn\n          // Pass merge:false to make incoming always replace existing\n          // without any warnings about data clobbering.\n        : merge === false ? mergeFalseFn\n        : existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn\n        // Pass an array of strings to use those fields to compute a\n        // composite ID for objects of this typename.\n      : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n        // Pass a function to take full control over identification.\n      : typeof keyFields === \"function\" ? keyFields\n        // Leave existing.keyFn unchanged if above cases fail.\n      : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach((fieldName) => {\n        const existing = this.getFieldPolicy(typename, fieldName, true)!;\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn\n              // Pass an array of strings to use named arguments to\n              // compute a composite identity for the field.\n            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n              // Pass a function to take full control over field identity.\n            : typeof keyArgs === \"function\" ? keyArgs\n              // Leave existing.keyFn unchanged if above cases fail.\n            : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(\n        !old || old === which,\n        `Cannot change root %s __typename more than once`,\n        which\n      );\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach((supertype) => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach((subtype) => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] = (this.typePolicies[\n        typename\n      ] = Object.create(null));\n      policy.fields = Object.create(null);\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      let supertypes = this.supertypeMap.get(typename);\n      if (!supertypes && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes = this.getSupertypeSet(typename, true)!;\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach((regExp, fuzzy) => {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            const fuzzySupertypes = this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach((supertype) =>\n                supertypes!.add(supertype)\n              );\n            }\n          }\n        });\n      }\n      if (supertypes && supertypes.size) {\n        supertypes.forEach((supertype) => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach((policy) => {\n        this.updateTypePolicy(typename, policy);\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string,\n    createIfMissing: boolean\n  ):\n    | {\n        keyFn?: KeyArgsFunction;\n        read?: FieldReadFunction<any>;\n        merge?: FieldMergeFunction<any>;\n      }\n    | undefined {\n    if (typename) {\n      const fieldPolicies = this.getTypePolicy(typename).fields;\n      return (\n        fieldPolicies[fieldName] ||\n        (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)))\n      );\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, (supertypeSet = new Set<string>()));\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (\n          supertypeSet &&\n          supertypeSet.size &&\n          workQueue.indexOf(supertypeSet) < 0\n        ) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(\n                `Inferring subtype %s of supertype %s`,\n                typename,\n                supertype\n              );\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (\n          needToCheckFuzzySubtypes &&\n          // Start checking fuzzy subtypes only after exhausting all\n          // non-fuzzy subtypes (after the final iteration of the loop).\n          i === workQueue.length - 1 &&\n          // We could wait to compare fragment.selectionSet to result\n          // after we verify the supertype, but this check is often less\n          // expensive than that search, and we will have to do the\n          // comparison anyway whenever we find a potential match.\n          selectionSetMatchesResult(fragment.selectionSet, result!, variables)\n        ) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    let storeFieldName: Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName =\n        fieldSpec.field ?\n          storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(\n        objectOrReference,\n        \"__typename\"\n      );\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(\n      objectOrReference,\n      storeFieldName\n    );\n    const policy = this.getFieldPolicy(options.typename, fieldName, false);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference) ?\n            objectOrReference.__ref\n          : objectOrReference,\n          storeFieldName\n        )\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [\n        existing,\n        readOptions,\n      ]) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getReadFunction(\n    typename: string | undefined,\n    fieldName: string\n  ): FieldReadFunction | undefined {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined = this.getFieldPolicy(parentTypename, fieldName, false);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(\n        existing as StoreObject,\n        incoming as StoreObject\n      );\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(\n      existing,\n      incoming,\n      makeFieldFunctionOptions(\n        this,\n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0,\n        {\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        },\n        context,\n        storage || Object.create(null)\n      )\n    );\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField<T>() {\n      return policies.readField<T>(\n        normalizeReadFieldOptions(arguments, objectOrReference, variables),\n        context\n      );\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nexport function normalizeReadFieldOptions(\n  readFieldArgs: IArguments,\n  objectOrReference: StoreObject | Reference | undefined,\n  variables?: ReadMergeModifyContext[\"variables\"]\n): ReadFieldOptions {\n  const { 0: fieldNameOrOptions, 1: from, length: argc } = readFieldArgs;\n\n  let options: ReadFieldOptions;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference,\n    };\n  } else {\n    options = { ...fieldNameOrOptions };\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    invariant.warn(\n      `Undefined 'from' passed to readField with arguments %s`,\n      stringifyForDisplay(Array.from(readFieldArgs))\n    );\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (\n        storeValueIsStoreObject(existing) &&\n        storeValueIsStoreObject(incoming)\n      ) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}