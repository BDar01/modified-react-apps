{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { addNonReactiveToNamedFragments, hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, isFullyUnmaskedOperation, removeDirectivesFromDocument } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\n\nvar QueryManager =\n/** @class */\nfunction () {\n  function QueryManager(options) {\n    var _this = this;\n\n    this.clientAwareness = {}; // All the queries that the QueryManager is currently managing (not\n    // including mutations and subscriptions).\n\n    this.queries = new Map(); // Maps from queryId strings to Promise rejection functions for\n    // currently active queries and fetches.\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n\n    this.fetchCancelFns = new Map();\n    this.transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] || 2000\n    /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */\n    );\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1; // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n\n    this.inFlightLinkObservables = new Trie(false);\n    this.noCacheWarningsByQueryId = new Set();\n    var defaultDocumentTransform = new DocumentTransform(function (document) {\n      return _this.cache.transformDocument(document);\n    }, // Allow the apollo cache to manage its own transform caches\n    {\n      cache: false\n    });\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    var documentTransform = options.documentTransform;\n    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform) // The custom document transform may add new fragment spreads or new\n    // field selections, so we want to give the cache a chance to run\n    // again. For example, the InMemoryCache adds __typename to field\n    // selections and fragments from the fragment registry.\n    .concat(defaultDocumentTransform) : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n\n    if (this.onBroadcast = options.onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n\n\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(newInvariantError(27));\n  };\n\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n\n  QueryManager.prototype.mutate = function (_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n      var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n\n      var _c, _d;\n\n      var mutation = _b.mutation,\n          variables = _b.variables,\n          optimisticResponse = _b.optimisticResponse,\n          updateQueries = _b.updateQueries,\n          _e = _b.refetchQueries,\n          refetchQueries = _e === void 0 ? [] : _e,\n          _f = _b.awaitRefetchQueries,\n          awaitRefetchQueries = _f === void 0 ? false : _f,\n          updateWithProxyFn = _b.update,\n          onQueryUpdated = _b.onQueryUpdated,\n          _g = _b.fetchPolicy,\n          fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || \"network-only\" : _g,\n          _h = _b.errorPolicy,\n          errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || \"none\" : _h,\n          keepRootFields = _b.keepRootFields,\n          context = _b.context;\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            invariant(mutation, 28);\n            invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 29);\n            mutationId = this.generateMutationId();\n            mutation = this.cache.transformForLink(this.transform(mutation));\n            hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n            variables = this.getVariables(mutation, variables);\n            if (!hasClientExports) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.localState.addExportedVariables(mutation, variables, context)];\n\n          case 1:\n            variables = _j.sent();\n            _j.label = 2;\n\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n            isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {\n              mutationId: mutationId,\n              document: mutation,\n              variables: variables,\n              fetchPolicy: fetchPolicy,\n              errorPolicy: errorPolicy,\n              context: context,\n              updateQueries: updateQueries,\n              update: updateWithProxyFn,\n              keepRootFields: keepRootFields\n            });\n            this.broadcastQueries();\n            self = this;\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: isOptimistic ? optimisticResponse : void 0\n              }), variables, {}, false), function (result) {\n                if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                  throw new ApolloError({\n                    graphQLErrors: getGraphQLErrorsFromResult(result)\n                  });\n                }\n\n                if (mutationStoreValue) {\n                  mutationStoreValue.loading = false;\n                  mutationStoreValue.error = null;\n                }\n\n                var storeResult = __assign({}, result);\n\n                if (typeof refetchQueries === \"function\") {\n                  refetchQueries = refetchQueries(storeResult);\n                }\n\n                if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                  delete storeResult.errors;\n                }\n\n                return self.markMutationResult({\n                  mutationId: mutationId,\n                  result: storeResult,\n                  document: mutation,\n                  variables: variables,\n                  fetchPolicy: fetchPolicy,\n                  errorPolicy: errorPolicy,\n                  context: context,\n                  update: updateWithProxyFn,\n                  updateQueries: updateQueries,\n                  awaitRefetchQueries: awaitRefetchQueries,\n                  refetchQueries: refetchQueries,\n                  removeOptimistic: isOptimistic ? mutationId : void 0,\n                  onQueryUpdated: onQueryUpdated,\n                  keepRootFields: keepRootFields\n                });\n              }).subscribe({\n                next: function (storeResult) {\n                  self.broadcastQueries(); // Since mutations might receive multiple payloads from the\n                  // ApolloLink chain (e.g. when used with @defer),\n                  // we resolve with a SingleExecutionResult or after the final\n                  // ExecutionPatchResult has arrived and we have assembled the\n                  // multipart response into a single result.\n\n                  if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                    resolve(__assign(__assign({}, storeResult), {\n                      data: self.maskOperation({\n                        document: mutation,\n                        data: storeResult.data,\n                        fetchPolicy: fetchPolicy,\n                        id: mutationId\n                      })\n                    }));\n                  }\n                },\n                error: function (err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n\n                  if (isOptimistic) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n\n                  self.broadcastQueries();\n                  reject(err instanceof ApolloError ? err : new ApolloError({\n                    networkError: err\n                  }));\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n\n    var result = mutation.result;\n    var cacheWrites = [];\n    var skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables\n        });\n      }\n\n      if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n        var diff = cache.diff({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true\n        });\n        var mergedData = void 0;\n\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          result.data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables\n          });\n        }\n      }\n\n      var updateQueries_1 = mutation.updateQueries;\n\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n\n          var updater = updateQueries_1[queryName];\n\n          var _b = _this.queries.get(queryId),\n              document = _b.document,\n              variables = _b.variables; // Read the current query result from the store.\n\n\n          var _c = cache.diff({\n            query: document,\n            variables: variables,\n            returnPartialData: true,\n            optimistic: false\n          }),\n              currentQueryResult = _c.result,\n              complete = _c.complete;\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            }); // Write the modified result back into the store if we got a new result.\n\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (cacheWrites.length > 0 || (mutation.refetchQueries || \"\").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n      var results_1 = [];\n      this.refetchQueries({\n        updateCache: function (cache) {\n          if (!skipCache) {\n            cacheWrites.forEach(function (write) {\n              return cache.write(write);\n            });\n          } // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n\n\n          var update = mutation.update; // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n\n          var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              var diff = cache.diff({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: _this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true\n              });\n\n              if (diff.complete) {\n                result = __assign(__assign({}, result), {\n                  data: diff.result\n                });\n\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            } // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n\n\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables\n              });\n            }\n          } // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n\n\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields: function (value, _a) {\n                var fieldName = _a.fieldName,\n                    DELETE = _a.DELETE;\n                return fieldName === \"__typename\" ? value : DELETE;\n              }\n            });\n          }\n        },\n        include: mutation.refetchQueries,\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null\n      }).forEach(function (result) {\n        return results_1.push(result);\n      });\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results_1).then(function () {\n          return result;\n        });\n      }\n    }\n\n    return Promise.resolve(result);\n  };\n\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables, {\n      IGNORE: IGNORE\n    }) : optimisticResponse;\n\n    if (data === IGNORE) {\n      return false;\n    }\n\n    this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        globalThis.__DEV__ !== false && invariant.error(error);\n      }\n    }, mutation.mutationId);\n    return true;\n  };\n\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;\n  };\n\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n\n  QueryManager.prototype.transform = function (document) {\n    return this.documentTransform.transformDocument(document);\n  };\n\n  QueryManager.prototype.getDocumentInfo = function (document) {\n    var transformCache = this.transformCache;\n\n    if (!transformCache.has(document)) {\n      var cacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument([{\n          name: \"client\",\n          remove: true\n        }, {\n          name: \"connection\"\n        }, {\n          name: \"nonreactive\"\n        }, {\n          name: \"unmask\"\n        }], document),\n        defaultVars: getDefaultValues(getOperationDefinition(document)),\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: __assign(__assign({}, document), {\n          definitions: document.definitions.map(function (def) {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return __assign(__assign({}, def), {\n                operation: \"query\"\n              });\n            }\n\n            return def;\n          })\n        })\n      };\n      transformCache.set(document, cacheEntry);\n    }\n\n    return transformCache.get(document);\n  };\n\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n  };\n\n  QueryManager.prototype.watchQuery = function (options) {\n    var query = this.transform(options.query); // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(query, options.variables)\n    });\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    var queryInfo = new QueryInfo(this);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    observable[\"lastQuery\"] = query;\n    this.queries.set(observable.queryId, queryInfo); // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables\n    });\n    return observable;\n  };\n\n  QueryManager.prototype.query = function (options, queryId) {\n    var _this = this;\n\n    if (queryId === void 0) {\n      queryId = this.generateQueryId();\n    }\n\n    invariant(options.query, 30);\n    invariant(options.query.kind === \"Document\", 31);\n    invariant(!options.returnPartialData, 32);\n    invariant(!options.pollInterval, 33);\n    var query = this.transform(options.query);\n    return this.fetchQuery(queryId, __assign(__assign({}, options), {\n      query: query\n    })).then(function (result) {\n      return result && __assign(__assign({}, result), {\n        data: _this.maskOperation({\n          document: query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id: queryId\n        })\n      });\n    }).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n\n  QueryManager.prototype.clearStore = function (options) {\n    if (options === void 0) {\n      options = {\n        discardWatches: true\n      };\n    } // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n\n\n    this.cancelPendingFetches(newInvariantError(34));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    } // begin removing data from the store\n\n\n    return this.cache.reset(options);\n  };\n\n  QueryManager.prototype.getObservableQueries = function (include) {\n    var _this = this;\n\n    if (include === void 0) {\n      include = \"active\";\n    }\n\n    var queries = new Map();\n    var queryNamesAndDocs = new Map();\n    var legacyQueryOptions = new Set();\n\n    if (Array.isArray(include)) {\n      include.forEach(function (desc) {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(_this.transform(desc), false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(function (_a, queryId) {\n      var oq = _a.observableQuery,\n          document = _a.document;\n\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        var queryName = oq.queryName,\n            fetchPolicy = oq.options.fetchPolicy;\n\n        if (fetchPolicy === \"standby\" || include === \"active\" && !oq.hasObservers()) {\n          return;\n        }\n\n        if (include === \"active\" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(function (options) {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n\n        var queryInfo = _this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables\n        });\n\n        var oq = new ObservableQuery({\n          queryManager: _this,\n          queryInfo: queryInfo,\n          options: __assign(__assign({}, options), {\n            fetchPolicy: \"network-only\"\n          })\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach(function (included, nameOrDoc) {\n        if (!included) {\n          globalThis.__DEV__ !== false && invariant.warn(typeof nameOrDoc === \"string\" ? 35 : 36, nameOrDoc);\n        }\n      });\n    }\n\n    return queries;\n  };\n\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n\n    var observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n      var fetchPolicy = observableQuery.options.fetchPolicy;\n      observableQuery.resetLastResults();\n\n      if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n\n      _this.getQuery(queryId).setDiff(null);\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n\n  QueryManager.prototype.setObservableQuery = function (observableQuery) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  };\n\n  QueryManager.prototype.startGraphQLSubscription = function (options) {\n    var _this = this;\n\n    var query = options.query,\n        variables = options.variables;\n    var fetchPolicy = options.fetchPolicy,\n        _a = options.errorPolicy,\n        errorPolicy = _a === void 0 ? \"none\" : _a,\n        _b = options.context,\n        context = _b === void 0 ? {} : _b,\n        _c = options.extensions,\n        extensions = _c === void 0 ? {} : _c;\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    var makeObservable = function (variables) {\n      return _this.getObservableFromLink(query, context, variables, extensions).map(function (result) {\n        if (fetchPolicy !== \"no-cache\") {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: \"ROOT_SUBSCRIPTION\",\n              variables: variables\n            });\n          }\n\n          _this.broadcastQueries();\n        }\n\n        var hasErrors = graphQLResultHasError(result);\n        var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n\n        if (hasErrors || hasProtocolErrors) {\n          var errors = {};\n\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          } // `errorPolicy` is a mechanism for handling GraphQL errors, according\n          // to our documentation, so we throw protocol errors regardless of the\n          // set error policy.\n\n\n          if (errorPolicy === \"none\" || hasProtocolErrors) {\n            throw new ApolloError(errors);\n          }\n        }\n\n        if (errorPolicy === \"ignore\") {\n          delete result.errors;\n        }\n\n        return result;\n      });\n    };\n\n    if (this.getDocumentInfo(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n\n    return makeObservable(variables);\n  };\n\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n\n  QueryManager.prototype.removeQuery = function (queryId) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  };\n\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      return info.notify();\n    });\n  };\n\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, extensions, // Prefer context.queryDeduplication if specified.\n  deduplication) {\n    var _this = this;\n\n    var _a;\n\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n\n    var observable;\n\n    var _b = this.getDocumentInfo(query),\n        serverQuery = _b.serverQuery,\n        clientQuery = _b.clientQuery;\n\n    if (serverQuery) {\n      var _c = this,\n          inFlightLinkObservables_1 = _c.inFlightLinkObservables,\n          link = _c.link;\n\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        })),\n        extensions: extensions\n      };\n      context = operation.context;\n\n      if (deduplication) {\n        var printedServerQuery_1 = print(serverQuery);\n        var varJson_1 = canonicalStringify(variables);\n        var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n        observable = entry.observable;\n\n        if (!observable) {\n          var concast = new Concast([execute(link, operation)]);\n          observable = entry.observable = concast;\n          concast.beforeNext(function () {\n            inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n\n    return observable;\n  };\n\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n    var requestId = queryInfo.lastRequestId = this.generateRequestId(); // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n\n    var linkDocument = this.cache.transformForLink(options.query);\n    return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n      var graphQLErrors = getGraphQLErrorsFromResult(result);\n      var hasErrors = graphQLErrors.length > 0;\n      var errorPolicy = options.errorPolicy; // If we interrupted this request by calling getResultsFromLink again\n      // with the same QueryInfo object, we ignore the old results.\n\n      if (requestId >= queryInfo.lastRequestId) {\n        if (hasErrors && errorPolicy === \"none\") {\n          // Throwing here effectively calls observer.error.\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: graphQLErrors\n          }));\n        } // Use linkDocument rather than queryInfo.document so the\n        // operation/fragments used to write the result are the same as the\n        // ones used to obtain it from the link.\n\n\n        queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n        queryInfo.markReady();\n      }\n\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: NetworkStatus.ready\n      }; // In the case we start multiple network requests simulatenously, we\n      // want to ensure we properly set `data` if we're reporting on an old\n      // result which will not be caught by the conditional above that ends up\n      // throwing the markError result.\n\n      if (hasErrors && errorPolicy === \"none\") {\n        aqr.data = void 0;\n      }\n\n      if (hasErrors && errorPolicy !== \"ignore\") {\n        aqr.errors = graphQLErrors;\n        aqr.networkStatus = NetworkStatus.error;\n      }\n\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      }); // Avoid storing errors from older interrupted queries.\n\n      if (requestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n\n      throw error;\n    });\n  };\n\n  QueryManager.prototype.fetchConcastWithInfo = function (queryId, options, // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus, query) {\n    var _this = this;\n\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    if (query === void 0) {\n      query = options.query;\n    }\n\n    var variables = this.getVariables(query, options.variables);\n    var queryInfo = this.getQuery(queryId);\n    var defaults = this.defaultOptions.watchQuery;\n    var _a = options.fetchPolicy,\n        fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a,\n        _b = options.errorPolicy,\n        errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b,\n        _c = options.returnPartialData,\n        returnPartialData = _c === void 0 ? false : _c,\n        _d = options.notifyOnNetworkStatusChange,\n        notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n        _e = options.context,\n        context = _e === void 0 ? {} : _e;\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n\n    var fromVariables = function (variables) {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n\n      if ( // If we're in standby, postpone advancing options.fetchPolicy using\n      // applyNextFetchPolicy.\n      normalized.fetchPolicy !== \"standby\" && // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n      // this is another way to detect when nothing was done/fetched.\n      sourcesWithInfo.sources.length > 0 && queryInfo.observableQuery) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n\n      return sourcesWithInfo;\n    }; // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n\n\n    var cleanupCancelFn = function () {\n      return _this.fetchCancelFns.delete(queryId);\n    };\n\n    this.fetchCancelFns.set(queryId, function (reason) {\n      cleanupCancelFn(); // This delay ensures the concast variable has been initialized.\n\n      setTimeout(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast, containsDataFromLink; // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function (sourcesWithInfo) {\n        return sourcesWithInfo.sources;\n      })); // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n\n      containsDataFromLink = true;\n    } else {\n      var sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n    return {\n      concast: concast,\n      fromLink: containsDataFromLink\n    };\n  };\n\n  QueryManager.prototype.refetchQueries = function (_a) {\n    var _this = this;\n\n    var updateCache = _a.updateCache,\n        include = _a.include,\n        _b = _a.optimistic,\n        optimistic = _b === void 0 ? false : _b,\n        _c = _a.removeOptimistic,\n        removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c,\n        onQueryUpdated = _a.onQueryUpdated;\n    var includedQueriesById = new Map();\n\n    if (include) {\n      this.getObservableQueries(include).forEach(function (oq, queryId) {\n        includedQueriesById.set(queryId, {\n          oq: oq,\n          lastDiff: _this.getQuery(queryId).getDiff()\n        });\n      });\n    }\n\n    var results = new Map();\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic: removeOptimistic,\n        onWatchUpdated: function (watch, diff, lastDiff) {\n          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n              var result = onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              } // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n\n\n              if (result !== false) {\n                results.set(oq, result);\n              } // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n\n\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, {\n                oq: oq,\n                lastDiff: lastDiff,\n                diff: diff\n              });\n            }\n          }\n        }\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(function (_a, queryId) {\n        var oq = _a.oq,\n            lastDiff = _a.lastDiff,\n            diff = _a.diff;\n        var result; // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n\n        if (onQueryUpdated) {\n          if (!diff) {\n            var info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n\n            diff = info.getDiff();\n          }\n\n          result = onQueryUpdated(oq, diff, lastDiff);\n        } // Otherwise, we fall back to refetching.\n\n\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          _this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  };\n\n  QueryManager.prototype.maskOperation = function (options) {\n    var _a, _b, _c;\n\n    var document = options.document,\n        data = options.data;\n\n    if (globalThis.__DEV__ !== false) {\n      var fetchPolicy = options.fetchPolicy,\n          id = options.id;\n      var operationType = (_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation;\n      var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : \"o\") + id;\n\n      if (this.dataMasking && fetchPolicy === \"no-cache\" && !isFullyUnmaskedOperation(document) && !this.noCacheWarningsByQueryId.has(operationId)) {\n        this.noCacheWarningsByQueryId.add(operationId);\n        globalThis.__DEV__ !== false && invariant.warn(37, (_c = getOperationName(document)) !== null && _c !== void 0 ? _c : \"Unnamed \".concat(operationType !== null && operationType !== void 0 ? operationType : \"operation\"));\n      }\n    }\n\n    return this.dataMasking ? maskOperation(data, document, this.cache) : data;\n  };\n\n  QueryManager.prototype.maskFragment = function (options) {\n    var data = options.data,\n        fragment = options.fragment,\n        fragmentName = options.fragmentName;\n    return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;\n  };\n\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus) {\n    var _this = this;\n\n    var query = _a.query,\n        variables = _a.variables,\n        fetchPolicy = _a.fetchPolicy,\n        refetchWritePolicy = _a.refetchWritePolicy,\n        errorPolicy = _a.errorPolicy,\n        returnPartialData = _a.returnPartialData,\n        context = _a.context,\n        notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n    var oldNetworkStatus = queryInfo.networkStatus;\n    queryInfo.init({\n      document: query,\n      variables: variables,\n      networkStatus: networkStatus\n    });\n\n    var readCache = function () {\n      return queryInfo.getDiff();\n    };\n\n    var resultsFromCache = function (diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n\n      var data = diff.result;\n\n      if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      var fromData = function (data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n\n      if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data || void 0);\n        });\n      } // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n\n\n      if (errorPolicy === \"none\" && networkStatus === NetworkStatus.refetch && Array.isArray(diff.missing)) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0\n    /* CacheWriteBehavior.FORBID */\n    // Watched queries must opt into overwriting existing data on refetch,\n    // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n    : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1\n    /* CacheWriteBehavior.OVERWRITE */\n    : 2\n    /* CacheWriteBehavior.MERGE */\n    ;\n\n    var resultsFromLink = function () {\n      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n        query: query,\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n\n    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              sources: [resultsFromCache(diff, queryInfo.markReady())]\n            };\n          }\n\n          if (returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n\n          if (diff.complete || returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())]\n        };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()]\n          };\n        }\n\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]\n          };\n        }\n\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n\n      case \"standby\":\n        return {\n          fromLink: false,\n          sources: []\n        };\n    }\n  };\n\n  QueryManager.prototype.getQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n\n    return this.queries.get(queryId);\n  };\n\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign(__assign({}, this.defaultContext), newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n\n  return QueryManager;\n}();\n\nexport { QueryManager };","map":{"version":3,"mappings":"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","names":["invariant","newInvariantError","equal","execute","addNonReactiveToNamedFragments","hasDirectives","isExecutionPatchIncrementalResult","isExecutionPatchResult","isFullyUnmaskedOperation","removeDirectivesFromDocument","canonicalStringify","getDefaultValues","getOperationDefinition","getOperationName","hasClientExports","graphQLResultHasError","getGraphQLErrorsFromResult","Observable","asyncMap","isNonEmptyArray","Concast","makeUniqueId","isDocumentNode","isNonNullObject","DocumentTransform","mergeIncrementalData","ApolloError","isApolloError","graphQLResultHasProtocolErrors","ObservableQuery","logMissingFieldErrors","NetworkStatus","isNetworkRequestInFlight","QueryInfo","shouldWriteResult","PROTOCOL_ERRORS_SYMBOL","print","Object","prototype","hasOwnProperty","IGNORE","create","Trie","AutoCleanedWeakCache","cacheSizes","maskFragment","maskOperation","options","Map","Set","defaultDocumentTransform","document","cache","transformDocument","link","defaultOptions","queryDeduplication","clientAwareness","localState","ssrMode","assumeImmutableResults","dataMasking","documentTransform","concat","defaultContext","onBroadcast","mutationStore","QueryManager","queries","forEach","_info","queryId","_this","stopQueryNoBroadcast","cancelPendingFetches","error","fetchCancelFns","cancel","clear","_b","mutation","variables","optimisticResponse","updateQueries","_e","refetchQueries","_f","awaitRefetchQueries","updateWithProxyFn","onQueryUpdated","_g","fetchPolicy","mutate","_c","_h","errorPolicy","_d","keepRootFields","context","mutationId","generateMutationId","transformForLink","transform","getDocumentInfo","getVariables","addExportedVariables","_j","mutationStoreValue","loading","isOptimistic","markMutationOptimistic","update","broadcastQueries","self","Promise","resolve","reject","getObservableFromLink","__assign","result","graphQLErrors","storeResult","errors","markMutationResult","removeOptimistic","subscribe","next","hasNext","data","id","err","networkError","cacheWrites","skipCache","push","dataId","query","incremental","diff","asQuery","optimistic","returnPartialData","mergedData","updateQueries_1","_a","observableQuery","queryName","call","updater","get","currentQueryResult","complete","nextQueryResult","mutationResult","queryVariables","length","results_1","updateCache","write","isFinalResult","modify","fields","value","fieldName","DELETE","include","all","then","recordOptimisticTransaction","globalThis","networkStatus","fetchConcastWithInfo","concast","promise","store","info","queryInfo","undefined","transformCache","has","cacheEntry","hasForcedResolvers","shouldForceResolvers","hasNonreactiveDirective","nonReactiveQuery","clientQuery","serverQuery","name","remove","defaultVars","definitions","map","def","kind","operation","set","notifyOnNetworkStatusChange","observable","queryManager","init","generateQueryId","pollInterval","fetchQuery","finally","generateRequestId","stopQueryInStore","stopQueryInStoreNoBroadcast","clearStore","discardWatches","getObservableQueries","queryNamesAndDocs","legacyQueryOptions","Array","desc","oq","setObservableQuery","included","nameOrDoc","__DEV__","includeStandby","observableQueryPromises","setDiff","extensions","hasErrors","hasProtocolErrors","protocolErrors","observablePromise_1","makeObservable","observer","sub","delete","deduplication","inFlightLinkObservables_1","operationName","forceFetch","varJson_1","printedServerQuery_1","entry","remoteResult","aqr","watchQuery","defaults","normalized","fromVariables","sourcesWithInfo","cleanupCancelFn","setTimeout","reason","containsDataFromLink","fromLink","includedQueriesById","lastDiff","getDiff","onWatchUpdated","watcher","results","noCacheWarningsByQueryId","operationId","add","fragment","fragmentName","refetchWritePolicy","oldNetworkStatus","readCache","resultsFromCache","missing","fromData","of","partial","runResolvers","onlyRunForcedResolvers","resolved","refetch","isArray","cacheWriteBehavior","resultsFromLink","getResultsFromLink","shouldNotify","sources","markReady","newContext","prepareContext"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/core/QueryManager.ts"],"sourcesContent":["import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode } from \"graphql\";\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from \"@wry/equality\";\n\nimport type { ApolloLink, FetchResult } from \"../link/core/index.js\";\nimport { execute } from \"../link/core/index.js\";\nimport {\n  addNonReactiveToNamedFragments,\n  defaultCacheSizes,\n  hasDirectives,\n  isExecutionPatchIncrementalResult,\n  isExecutionPatchResult,\n  isFullyUnmaskedOperation,\n  removeDirectivesFromDocument,\n} from \"../utilities/index.js\";\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\n\nimport type {\n  ObservableSubscription,\n  ConcastSourcesArray,\n} from \"../utilities/index.js\";\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  getGraphQLErrorsFromResult,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n  DocumentTransform,\n} from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport {\n  ApolloError,\n  isApolloError,\n  graphQLResultHasProtocolErrors,\n} from \"../errors/index.js\";\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n  DefaultContext,\n} from \"./types.js\";\nimport type { LocalState } from \"./LocalState.js\";\n\nimport type { QueryStoreValue } from \"./QueryInfo.js\";\nimport {\n  QueryInfo,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from \"./QueryInfo.js\";\nimport type { ApolloErrorOptions } from \"../errors/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nimport type { IgnoreModifier } from \"../cache/core/types/common.js\";\nimport type { TODO } from \"../utilities/types/TODO.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst IGNORE: IgnoreModifier = Object.create(null);\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  nonReactiveQuery: DocumentNode;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\nimport type { DefaultOptions } from \"./ApolloClient.js\";\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\n\ninterface MaskFragmentOptions<TData> {\n  fragment: DocumentNode;\n  data: TData;\n  fragmentName?: string;\n}\n\ninterface MaskOperationOptions<TData> {\n  document: DocumentNode;\n  data: TData;\n  id: string;\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\nexport interface QueryManagerOptions<TStore> {\n  cache: ApolloCache<TStore>;\n  link: ApolloLink;\n  defaultOptions: DefaultOptions;\n  documentTransform: DocumentTransform | null | undefined;\n  queryDeduplication: boolean;\n  onBroadcast: undefined | (() => void);\n  ssrMode: boolean;\n  clientAwareness: Record<string, string>;\n  localState: LocalState<TStore>;\n  assumeImmutableResults: boolean;\n  defaultContext: Partial<DefaultContext> | undefined;\n  dataMasking: boolean;\n}\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n  public readonly defaultContext: Partial<DefaultContext>;\n  public readonly dataMasking: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor(options: QueryManagerOptions<TStore>) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    const documentTransform = options.documentTransform;\n    this.documentTransform =\n      documentTransform ?\n        defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n\n    if ((this.onBroadcast = options.onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TContext extends Record<string, any>,\n    TCache extends ApolloCache<any>,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<\n    FetchResult<MaybeMasked<TData>>\n  > {\n    invariant(\n      mutation,\n      \"mutation option is required. You must specify your GraphQL document in the mutation option.\"\n    );\n\n    invariant(\n      fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\",\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = (await this.localState.addExportedVariables(\n        mutation,\n        variables,\n        context\n      )) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    const isOptimistic =\n      optimisticResponse &&\n      this.markMutationOptimistic<TData, TVariables, TContext, TCache>(\n        optimisticResponse,\n        {\n          mutationId,\n          document: mutation,\n          variables,\n          fetchPolicy,\n          errorPolicy,\n          context,\n          updateQueries,\n          update: updateWithProxyFn,\n          keepRootFields,\n        }\n      );\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n          },\n          variables,\n          {},\n          false\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n            throw new ApolloError({\n              graphQLErrors: getGraphQLErrorsFromResult(result),\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(\n              storeResult as FetchResult<Unmasked<TData>>\n            );\n          }\n\n          if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<TData, TVariables, TContext, TCache>({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: isOptimistic ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        }\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n            resolve({\n              ...storeResult,\n              data: self.maskOperation({\n                document: mutation,\n                data: storeResult.data,\n                fetchPolicy,\n                id: mutationId,\n              }) as any,\n            });\n          }\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (isOptimistic) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : (\n              new ApolloError({\n                networkError: err,\n              })\n            )\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables,\n        });\n      }\n      if (\n        isExecutionPatchIncrementalResult(result) &&\n        isNonEmptyArray(result.incremental)\n      ) {\n        const diff = cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        });\n        let mergedData;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          (result as FetchResult).data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables,\n          });\n        }\n      }\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result as FetchResult<Unmasked<TData>>,\n              queryName: (document && getOperationName(document)) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      (mutation.refetchQueries || \"\").length > 0 ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache) => {\n          if (!skipCache) {\n            cacheWrites.forEach((write) => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          const isFinalResult =\n            !isExecutionPatchResult(result) ||\n            (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...(result as FetchResult), data: diff.result };\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache as TCache, result as FetchResult<Unmasked<TData>>, {\n                context: mutation.context,\n                variables: mutation.variables,\n              });\n            }\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n      }).forEach((result) => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean;\n    }\n  ) {\n    const data =\n      typeof optimisticResponse === \"function\" ?\n        optimisticResponse(mutation.variables, { IGNORE })\n      : optimisticResponse;\n\n    if (data === IGNORE) {\n      return false;\n    }\n\n    this.cache.recordOptimisticTransaction((cache) => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>(\n          {\n            ...mutation,\n            result: { data },\n          },\n          cache\n        );\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n\n    return true;\n  }\n\n  public fetchQuery<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchConcastWithInfo(queryId, options, networkStatus).concast\n      .promise as TODO;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new AutoCleanedWeakCache<\n    DocumentNode,\n    TransformCacheEntry\n  >(\n    cacheSizes[\"queryManager.getDocumentInfo\"] ||\n      defaultCacheSizes[\"queryManager.getDocumentInfo\"]\n  );\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n            { name: \"unmask\" },\n          ],\n          document\n        ),\n        defaultVars: getDefaultValues(\n          getOperationDefinition(document)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): OperationVariables {\n    return {\n      ...this.getDocumentInfo(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<\n    T,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n    observable[\"lastQuery\"] = query;\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId()\n  ): Promise<ApolloQueryResult<MaybeMasked<TData>>> {\n    invariant(\n      options.query,\n      \"query option is required. You must specify your GraphQL document \" +\n        \"in the query option.\"\n    );\n\n    invariant(\n      options.query.kind === \"Document\",\n      'You must wrap the query string in a \"gql\" tag.'\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      \"returnPartialData option only supported on watchQuery.\"\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      \"pollInterval option only supported on watchQuery.\"\n    );\n\n    const query = this.transform(options.query);\n\n    return this.fetchQuery<TData, TVars>(queryId, { ...options, query })\n      .then(\n        (result) =>\n          result && {\n            ...result,\n            data: this.maskOperation({\n              document: query,\n              data: result.data,\n              fetchPolicy: options.fetchPolicy,\n              id: queryId,\n            }),\n          }\n      )\n      .finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.queries.forEach((queryInfo) => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNamesAndDocs = new Map<string | DocumentNode, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(this.transform(desc), false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndDocs.has(queryName)) ||\n          (document && queryNamesAndDocs.has(document))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach((included, nameOrDoc) => {\n        if (!included) {\n          invariant.warn(\n            typeof nameOrDoc === \"string\" ?\n              `Unknown query named \"%s\" requested in refetchQueries options.include array`\n            : `Unknown query %o requested in refetchQueries options.include array`,\n            nameOrDoc\n          );\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery, queryId) => {\n        const { fetchPolicy } = observableQuery.options;\n        observableQuery.resetLastResults();\n        if (\n          includeStandby ||\n          (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n        this.getQuery(queryId).setDiff(null);\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>(\n    options: SubscriptionOptions\n  ): Observable<FetchResult<T>> {\n    let { query, variables } = options;\n    const {\n      fetchPolicy,\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {},\n    } = options;\n\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(query, context, variables, extensions).map(\n        (result) => {\n          if (fetchPolicy !== \"no-cache\") {\n            // the subscription interface should handle not sending us results we no longer subscribe to.\n            // XXX I don't think we ever send in an object with errors, but we might in the future...\n            if (shouldWriteResult(result, errorPolicy)) {\n              this.cache.write({\n                query,\n                result: result.data,\n                dataId: \"ROOT_SUBSCRIPTION\",\n                variables: variables,\n              });\n            }\n\n            this.broadcastQueries();\n          }\n\n          const hasErrors = graphQLResultHasError(result);\n          const hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n          if (hasErrors || hasProtocolErrors) {\n            const errors: ApolloErrorOptions = {};\n            if (hasErrors) {\n              errors.graphQLErrors = result.errors;\n            }\n            if (hasProtocolErrors) {\n              errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n            }\n\n            // `errorPolicy` is a mechanism for handling GraphQL errors, according\n            // to our documentation, so we throw protocol errors regardless of the\n            // set error policy.\n            if (errorPolicy === \"none\" || hasProtocolErrors) {\n              throw new ApolloError(errors);\n            }\n          }\n\n          if (errorPolicy === \"ignore\") {\n            delete result.errors;\n          }\n\n          return result;\n        }\n      );\n\n    if (this.getDocumentInfo(query).hasClientExports) {\n      const observablePromise = this.localState\n        .addExportedVariables(query, variables, context)\n        .then(makeObservable);\n\n      return new Observable<FetchResult<T>>((observer) => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          (observable) => (sub = observable.subscribe(observer)),\n          observer.error\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach((info) => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Trie<{\n    observable?: Observable<FetchResult<any>>;\n  }>(false);\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    extensions?: Record<string, any>,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>> | undefined;\n\n    const { serverQuery, clientQuery } = this.getDocumentInfo(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication,\n        }),\n        extensions,\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const printedServerQuery = print(serverQuery);\n        const varJson = canonicalStringify(variables);\n\n        const entry = inFlightLinkObservables.lookup(\n          printedServerQuery,\n          varJson\n        );\n\n        observable = entry.observable;\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>,\n          ]);\n          observable = entry.observable = concast;\n\n          concast.beforeNext(() => {\n            inFlightLinkObservables.remove(printedServerQuery, varJson);\n          });\n        }\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>,\n        ]);\n      }\n    } else {\n      observable = new Concast([Observable.of({ data: {} } as FetchResult<T>)]);\n      context = this.prepareContext(context);\n    }\n\n    if (clientQuery) {\n      observable = asyncMap(observable, (result) => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<\n      WatchQueryOptions<TVars, TData>,\n      \"query\" | \"variables\" | \"context\" | \"fetchPolicy\" | \"errorPolicy\"\n    >\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables\n      ),\n\n      (result) => {\n        const graphQLErrors = getGraphQLErrorsFromResult(result);\n        const hasErrors = graphQLErrors.length > 0;\n        const { errorPolicy } = options;\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(\n              new ApolloError({\n                graphQLErrors,\n              })\n            );\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(\n            result,\n            linkDocument,\n            options,\n            cacheWriteBehavior\n          );\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        // In the case we start multiple network requests simulatenously, we\n        // want to ensure we properly set `data` if we're reporting on an old\n        // result which will not be caught by the conditional above that ends up\n        // throwing the markError result.\n        if (hasErrors && errorPolicy === \"none\") {\n          aqr.data = void 0 as TData;\n        }\n\n        if (hasErrors && errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      (networkError) => {\n        const error =\n          isApolloError(networkError) ? networkError : (\n            new ApolloError({ networkError })\n          );\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      }\n    );\n  }\n\n  private fetchConcastWithInfo<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n    query = options.query\n  ): ConcastAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const sourcesWithInfo = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        sourcesWithInfo.sources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options\n        );\n      }\n\n      return sourcesWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryId);\n    this.fetchCancelFns.set(queryId, (reason) => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    let concast: Concast<ApolloQueryResult<TData>>,\n      containsDataFromLink: boolean;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(\n        this.localState\n          .addExportedVariables(\n            normalized.query,\n            normalized.variables,\n            normalized.context\n          )\n          .then(fromVariables)\n          .then((sourcesWithInfo) => sourcesWithInfo.sources)\n      );\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return {\n      concast,\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache<TStore>,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<\n      string,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: this.getQuery(queryId).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloQueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            const info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private noCacheWarningsByQueryId = new Set<string>();\n\n  public maskOperation<TData = unknown>(\n    options: MaskOperationOptions<TData>\n  ): MaybeMasked<TData> {\n    const { document, data } = options;\n\n    if (__DEV__) {\n      const { fetchPolicy, id } = options;\n      const operationType = getOperationDefinition(document)?.operation;\n      const operationId = (operationType?.[0] ?? \"o\") + id;\n\n      if (\n        this.dataMasking &&\n        fetchPolicy === \"no-cache\" &&\n        !isFullyUnmaskedOperation(document) &&\n        !this.noCacheWarningsByQueryId.has(operationId)\n      ) {\n        this.noCacheWarningsByQueryId.add(operationId);\n\n        invariant.warn(\n          '[%s]: Fragments masked by data masking are inaccessible when using fetch policy \"no-cache\". Please add `@unmask` to each fragment spread to access the data.',\n          getOperationName(document) ??\n            `Unnamed ${operationType ?? \"operation\"}`\n        );\n      }\n    }\n\n    return (\n      this.dataMasking ?\n        maskOperation(data, document, this.cache)\n      : data) as MaybeMasked<TData>;\n  }\n\n  public maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>) {\n    const { data, fragment, fragmentName } = options;\n\n    return this.dataMasking ?\n        maskFragment(data, fragment, this.cache, fragmentName)\n      : data;\n  }\n\n  private fetchQueryByPolicy<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    {\n      query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus\n  ): SourcesAndInfo<TData> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff();\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) =>\n        Observable.of({\n          data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          ...(diff.complete ? null : { partial: true }),\n        } as ApolloQueryResult<TData>);\n\n      if (data && this.getDocumentInfo(query).hasForcedResolvers) {\n        return this.localState\n          .runResolvers({\n            document: query,\n            remoteResult: { data },\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n          })\n          .then((resolved) => fromData(resolved.data || void 0));\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        Array.isArray(diff.missing)\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID\n        // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n      : (\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ?\n        CacheWriteBehavior.OVERWRITE\n      : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, cacheWriteBehavior, {\n        query,\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            sources: [resultsFromCache(diff, queryInfo.markReady())],\n          };\n        }\n\n        if (returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n        };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"standby\":\n        return { fromLink: false, sources: [] };\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...this.defaultContext,\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface FetchConcastInfo {\n  // Metadata properties that can be returned in addition to the Concast.\n  fromLink: boolean;\n}\ninterface SourcesAndInfo<TData> extends FetchConcastInfo {\n  sources: ConcastSourcesArray<ApolloQueryResult<TData>>;\n}\ninterface ConcastAndInfo<TData> extends FetchConcastInfo {\n  concast: Concast<ApolloQueryResult<TData>>;\n}\n"]},"metadata":{},"sourceType":"module"}