{"ast":null,"code":"import { Kind } from \"graphql\";\nimport { getFragmentMaskMode, maybeDeepFreeze, resultKeyNameFromField } from \"../utilities/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nexport function maskDefinition(data, selectionSet, context) {\n  return disableWarningsSlot.withValue(true, function () {\n    var masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n\n    return masked;\n  });\n}\n\nfunction getMutableTarget(data, mutableTargets) {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  var mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(data, selectionSet, context, migration, path) {\n  var _a;\n\n  var knownChanged = context.knownChanged;\n  var memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++) {\n      var _c = _b[_i],\n          index = _c[0],\n          item = _c[1];\n\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      var masked = maskSelectionSet(item, selectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \"[\").concat(index, \"]\") : void 0);\n\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++) {\n    var selection = _e[_d];\n    var value = void 0; // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      var keyName = resultKeyNameFromField(selection);\n      var childSelectionSet = selection.selectionSet;\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        var masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \".\").concat(keyName) : void 0);\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!(globalThis.__DEV__ !== false)) {\n        memo[keyName] = value;\n      }\n\n      if (globalThis.__DEV__ !== false) {\n        if (migration && keyName !== \"__typename\" && // either the field is not present in the memo object\n        // or it has a `get` descriptor, not a `value` descriptor\n        // => it is a warning accessor and we can overwrite it\n        // with another accessor\n        !((_a = Object.getOwnPropertyDescriptor(memo, keyName)) === null || _a === void 0 ? void 0 : _a.value)) {\n          Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || \"\", context.operationName, context.operationType));\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {\n      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      var fragmentName = selection.name.value;\n      var fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));\n      invariant(fragment, 47, fragmentName);\n      var mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(data, fragment.selectionSet, context, mode === \"migrate\", path);\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  } // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n\n\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {\n  var getValue = function () {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    globalThis.__DEV__ !== false && invariant.warn(48, operationName ? \"\".concat(operationType, \" '\").concat(operationName, \"'\") : \"anonymous \".concat(operationType), \"\".concat(path, \".\").concat(fieldName).replace(/^\\./, \"\"));\n\n    getValue = function () {\n      return value;\n    };\n\n    return value;\n  };\n\n  return {\n    get: function () {\n      return getValue();\n    },\n    set: function (newValue) {\n      getValue = function () {\n        return newValue;\n      };\n    },\n    enumerable: true,\n    configurable: true\n  };\n}","map":{"version":3,"mappings":"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","names":["Kind","getFragmentMaskMode","maybeDeepFreeze","resultKeyNameFromField","disableWarningsSlot","invariant","maskDefinition","data","selectionSet","context","withValue","masked","maskSelectionSet","Object","isFrozen","getMutableTarget","mutableTargets","has","get","mutableTarget","Array","isArray","create","set","migration","path","memo","from","entries","_i","index","item","globalThis","concat","knownChanged","add","selections","_d","selection","value","kind","FIELD","keyName","childSelectionSet","getOwnPropertyDescriptor","_a","defineProperty","getAccessorWarningDescriptor","operationName","operationType","INLINE_FRAGMENT","typeCondition","cache","fragmentMatches","__typename","FRAGMENT_SPREAD","fragmentName","name","fragment","fragmentMap","lookupFragment","mode","keys","length","fieldName","getValue","replace","newValue","enumerable","configurable"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/masking/maskDefinition.ts"],"sourcesContent":["import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode, SelectionSetNode } from \"graphql\";\nimport {\n  getFragmentMaskMode,\n  maybeDeepFreeze,\n  resultKeyNameFromField,\n} from \"../utilities/index.js\";\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport type { ApolloCache } from \"../cache/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\n\ninterface MaskingContext {\n  operationType: \"query\" | \"mutation\" | \"subscription\" | \"fragment\";\n  operationName: string | undefined;\n  fragmentMap: FragmentMap;\n  cache: ApolloCache<unknown>;\n  mutableTargets: WeakMap<any, any>;\n  knownChanged: WeakSet<any>;\n}\n\nexport function maskDefinition(\n  data: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext\n) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\n\nfunction getMutableTarget(\n  data: Record<string, any>,\n  mutableTargets: WeakMap<any, any>\n): typeof data {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  const mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(\n  data: any,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext,\n  migration: boolean,\n  path?: string | undefined\n): typeof data {\n  const { knownChanged } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      const masked = maskSelectionSet(\n        item,\n        selectionSet,\n        context,\n        migration,\n        __DEV__ ? `${path || \"\"}[${index}]` : void 0\n      );\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (const selection of selectionSet.selections) {\n    let value: any;\n\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(\n          data[keyName],\n          childSelectionSet,\n          context,\n          migration,\n          __DEV__ ? `${path || \"\"}.${keyName}` : void 0\n        );\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (\n          migration &&\n          keyName !== \"__typename\" &&\n          // either the field is not present in the memo object\n          // or it has a `get` descriptor, not a `value` descriptor\n          // => it is a warning accessor and we can overwrite it\n          // with another accessor\n          !Object.getOwnPropertyDescriptor(memo, keyName)?.value\n        ) {\n          Object.defineProperty(\n            memo,\n            keyName,\n            getAccessorWarningDescriptor(\n              keyName,\n              value,\n              path || \"\",\n              context.operationName,\n              context.operationType\n            )\n          );\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (\n      selection.kind === Kind.INLINE_FRAGMENT &&\n      (!selection.typeCondition ||\n        context.cache.fragmentMatches!(selection, data.__typename))\n    ) {\n      value = maskSelectionSet(\n        data,\n        selection.selectionSet,\n        context,\n        migration,\n        path\n      );\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment: FragmentDefinitionNode | null =\n        context.fragmentMap[fragmentName] ||\n        (context.fragmentMap[fragmentName] =\n          context.cache.lookupFragment(fragmentName)!);\n      invariant(\n        fragment,\n        \"Could not find fragment with name '%s'.\",\n        fragmentName\n      );\n\n      const mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(\n          data,\n          fragment.selectionSet,\n          context,\n          mode === \"migrate\",\n          path\n        );\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(\n  fieldName: string,\n  value: any,\n  path: string,\n  operationName: string | undefined,\n  operationType: string\n): PropertyDescriptor {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    invariant.warn(\n      \"Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead.\",\n      operationName ?\n        `${operationType} '${operationName}'`\n      : `anonymous ${operationType}`,\n      `${path}.${fieldName}`.replace(/^\\./, \"\")\n    );\n\n    getValue = () => value;\n\n    return value;\n  };\n\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}