{"ast":null,"code":"import { AutoCleanedStrongCache, cacheSizes } from \"../../utilities/caching/index.js\";\nimport { registerGlobalCache } from \"../caching/getMemoryInternals.js\";\n/**\n * Like JSON.stringify, but with object keys always sorted in the same order.\n *\n * To achieve performant sorting, this function uses a Map from JSON-serialized\n * arrays of keys (in any order) to sorted arrays of the same keys, with a\n * single sorted array reference shared by all permutations of the keys.\n *\n * As a drawback, this function will add a little bit more memory for every\n * object encountered that has different (more, less, a different order of) keys\n * than in the past.\n *\n * In a typical application, this extra memory usage should not play a\n * significant role, as `canonicalStringify` will be called for only a limited\n * number of object shapes, and the cache will not grow beyond a certain point.\n * But in some edge cases, this could be a problem, so we provide\n * canonicalStringify.reset() as a way of clearing the cache.\n * */\n\nexport var canonicalStringify = Object.assign(function canonicalStringify(value) {\n  return JSON.stringify(value, stableObjectReplacer);\n}, {\n  reset: function () {\n    // Clearing the sortingMap will reclaim all cached memory, without\n    // affecting the logical results of canonicalStringify, but potentially\n    // sacrificing performance until the cache is refilled.\n    sortingMap = new AutoCleanedStrongCache(cacheSizes.canonicalStringify || 1000\n    /* defaultCacheSizes.canonicalStringify */\n    );\n  }\n});\n\nif (globalThis.__DEV__ !== false) {\n  registerGlobalCache(\"canonicalStringify\", function () {\n    return sortingMap.size;\n  });\n} // Values are JSON-serialized arrays of object keys (in any order), and values\n// are sorted arrays of the same keys.\n\n\nvar sortingMap;\ncanonicalStringify.reset(); // The JSON.stringify function takes an optional second argument called a\n// replacer function. This function is called for each key-value pair in the\n// object being stringified, and its return value is used instead of the\n// original value. If the replacer function returns a new value, that value is\n// stringified as JSON instead of the original value of the property.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter\n\nfunction stableObjectReplacer(key, value) {\n  if (value && typeof value === \"object\") {\n    var proto = Object.getPrototypeOf(value); // We don't want to mess with objects that are not \"plain\" objects, which\n    // means their prototype is either Object.prototype or null. This check also\n    // prevents needlessly rearranging the indices of arrays.\n\n    if (proto === Object.prototype || proto === null) {\n      var keys = Object.keys(value); // If keys is already sorted, let JSON.stringify serialize the original\n      // value instead of creating a new object with keys in the same order.\n\n      if (keys.every(everyKeyInOrder)) return value;\n      var unsortedKey = JSON.stringify(keys);\n      var sortedKeys = sortingMap.get(unsortedKey);\n\n      if (!sortedKeys) {\n        keys.sort();\n        var sortedKey = JSON.stringify(keys); // Checking for sortedKey in the sortingMap allows us to share the same\n        // sorted array reference for all permutations of the same set of keys.\n\n        sortedKeys = sortingMap.get(sortedKey) || keys;\n        sortingMap.set(unsortedKey, sortedKeys);\n        sortingMap.set(sortedKey, sortedKeys);\n      }\n\n      var sortedObject_1 = Object.create(proto); // Reassigning the keys in sorted order will cause JSON.stringify to\n      // serialize them in sorted order.\n\n      sortedKeys.forEach(function (key) {\n        sortedObject_1[key] = value[key];\n      });\n      return sortedObject_1;\n    }\n  }\n\n  return value;\n} // Since everything that happens in stableObjectReplacer benefits from being as\n// efficient as possible, we use a static function as the callback for\n// keys.every in order to test if the provided keys are already sorted without\n// allocating extra memory for a callback.\n\n\nfunction everyKeyInOrder(key, i, keys) {\n  return i === 0 || keys[i - 1] <= key;\n}","map":{"version":3,"mappings":"AAAA,SACEA,sBADF,EAEEC,UAFF,QAIO,kCAJP;AAKA,SAASC,mBAAT,QAAoC,kCAApC;AAEA;;;;;;;;;;;;;;;;;;AAiBA,OAAO,IAAMC,kBAAkB,GAAGC,MAAM,CAACC,MAAP,CAChC,SAASF,kBAAT,CAA4BG,KAA5B,EAAsC;AACpC,SAAOC,IAAI,CAACC,SAAL,CAAeF,KAAf,EAAsBG,oBAAtB,CAAP;AACD,CAH+B,EAIhC;AACEC,OAAK;AACH;AACA;AACA;AACAC,cAAU,GAAG,IAAIX,sBAAJ,CACXC,UAAU,CAACE,kBAAX,IAA6B;AAAA;AADlB,KAAb;AAGD;AARH,CAJgC,CAA3B;;AAgBP,IAAIS,UAAU,QAAV,KAAU,KAAd,EAAc;AACZV,qBAAmB,CAAC,oBAAD,EAAuB;AAAM,qBAAU,CAACW,IAAX;AAAe,GAA5C,CAAnB;AACD,C,CAED;AACA;;;AACA,IAAIF,UAAJ;AACAR,kBAAkB,CAACO,KAAnB,G,CAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,oBAAT,CAA8BK,GAA9B,EAA2CR,KAA3C,EAAqD;AACnD,MAAIA,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA9B,EAAwC;AACtC,QAAMS,KAAK,GAAGX,MAAM,CAACY,cAAP,CAAsBV,KAAtB,CAAd,CADsC,CAEtC;AACA;AACA;;AACA,QAAIS,KAAK,KAAKX,MAAM,CAACa,SAAjB,IAA8BF,KAAK,KAAK,IAA5C,EAAkD;AAChD,UAAMG,IAAI,GAAGd,MAAM,CAACc,IAAP,CAAYZ,KAAZ,CAAb,CADgD,CAEhD;AACA;;AACA,UAAIY,IAAI,CAACC,KAAL,CAAWC,eAAX,CAAJ,EAAiC,OAAOd,KAAP;AACjC,UAAMe,WAAW,GAAGd,IAAI,CAACC,SAAL,CAAeU,IAAf,CAApB;AACA,UAAII,UAAU,GAAGX,UAAU,CAACY,GAAX,CAAeF,WAAf,CAAjB;;AACA,UAAI,CAACC,UAAL,EAAiB;AACfJ,YAAI,CAACM,IAAL;AACA,YAAMC,SAAS,GAAGlB,IAAI,CAACC,SAAL,CAAeU,IAAf,CAAlB,CAFe,CAGf;AACA;;AACAI,kBAAU,GAAGX,UAAU,CAACY,GAAX,CAAeE,SAAf,KAA6BP,IAA1C;AACAP,kBAAU,CAACe,GAAX,CAAeL,WAAf,EAA4BC,UAA5B;AACAX,kBAAU,CAACe,GAAX,CAAeD,SAAf,EAA0BH,UAA1B;AACD;;AACD,UAAMK,cAAY,GAAGvB,MAAM,CAACwB,MAAP,CAAcb,KAAd,CAArB,CAhBgD,CAiBhD;AACA;;AACAO,gBAAU,CAACO,OAAX,CAAmB,UAACf,GAAD,EAAI;AACrBa,sBAAY,CAACb,GAAD,CAAZ,GAAoBR,KAAK,CAACQ,GAAD,CAAzB;AACD,OAFD;AAGA,aAAOa,cAAP;AACD;AACF;;AACD,SAAOrB,KAAP;AACD,C,CAED;AACA;AACA;AACA;;;AACA,SAASc,eAAT,CACEN,GADF,EAEEgB,CAFF,EAGEZ,IAHF,EAGyB;AAEvB,SAAOY,CAAC,KAAK,CAAN,IAAWZ,IAAI,CAACY,CAAC,GAAG,CAAL,CAAJ,IAAehB,GAAjC;AACD","names":["AutoCleanedStrongCache","cacheSizes","registerGlobalCache","canonicalStringify","Object","assign","value","JSON","stringify","stableObjectReplacer","reset","sortingMap","globalThis","size","key","proto","getPrototypeOf","prototype","keys","every","everyKeyInOrder","unsortedKey","sortedKeys","get","sort","sortedKey","set","sortedObject_1","create","forEach","i"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/utilities/common/canonicalStringify.ts"],"sourcesContent":["import {\n  AutoCleanedStrongCache,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/caching/index.js\";\nimport { registerGlobalCache } from \"../caching/getMemoryInternals.js\";\n\n/**\n * Like JSON.stringify, but with object keys always sorted in the same order.\n *\n * To achieve performant sorting, this function uses a Map from JSON-serialized\n * arrays of keys (in any order) to sorted arrays of the same keys, with a\n * single sorted array reference shared by all permutations of the keys.\n *\n * As a drawback, this function will add a little bit more memory for every\n * object encountered that has different (more, less, a different order of) keys\n * than in the past.\n *\n * In a typical application, this extra memory usage should not play a\n * significant role, as `canonicalStringify` will be called for only a limited\n * number of object shapes, and the cache will not grow beyond a certain point.\n * But in some edge cases, this could be a problem, so we provide\n * canonicalStringify.reset() as a way of clearing the cache.\n * */\nexport const canonicalStringify = Object.assign(\n  function canonicalStringify(value: any): string {\n    return JSON.stringify(value, stableObjectReplacer);\n  },\n  {\n    reset() {\n      // Clearing the sortingMap will reclaim all cached memory, without\n      // affecting the logical results of canonicalStringify, but potentially\n      // sacrificing performance until the cache is refilled.\n      sortingMap = new AutoCleanedStrongCache<string, readonly string[]>(\n        cacheSizes.canonicalStringify || defaultCacheSizes.canonicalStringify\n      );\n    },\n  }\n);\n\nif (__DEV__) {\n  registerGlobalCache(\"canonicalStringify\", () => sortingMap.size);\n}\n\n// Values are JSON-serialized arrays of object keys (in any order), and values\n// are sorted arrays of the same keys.\nlet sortingMap!: AutoCleanedStrongCache<string, readonly string[]>;\ncanonicalStringify.reset();\n\n// The JSON.stringify function takes an optional second argument called a\n// replacer function. This function is called for each key-value pair in the\n// object being stringified, and its return value is used instead of the\n// original value. If the replacer function returns a new value, that value is\n// stringified as JSON instead of the original value of the property.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter\nfunction stableObjectReplacer(key: string, value: any) {\n  if (value && typeof value === \"object\") {\n    const proto = Object.getPrototypeOf(value);\n    // We don't want to mess with objects that are not \"plain\" objects, which\n    // means their prototype is either Object.prototype or null. This check also\n    // prevents needlessly rearranging the indices of arrays.\n    if (proto === Object.prototype || proto === null) {\n      const keys = Object.keys(value);\n      // If keys is already sorted, let JSON.stringify serialize the original\n      // value instead of creating a new object with keys in the same order.\n      if (keys.every(everyKeyInOrder)) return value;\n      const unsortedKey = JSON.stringify(keys);\n      let sortedKeys = sortingMap.get(unsortedKey);\n      if (!sortedKeys) {\n        keys.sort();\n        const sortedKey = JSON.stringify(keys);\n        // Checking for sortedKey in the sortingMap allows us to share the same\n        // sorted array reference for all permutations of the same set of keys.\n        sortedKeys = sortingMap.get(sortedKey) || keys;\n        sortingMap.set(unsortedKey, sortedKeys);\n        sortingMap.set(sortedKey, sortedKeys);\n      }\n      const sortedObject = Object.create(proto);\n      // Reassigning the keys in sorted order will cause JSON.stringify to\n      // serialize them in sorted order.\n      sortedKeys.forEach((key) => {\n        sortedObject[key] = value[key];\n      });\n      return sortedObject;\n    }\n  }\n  return value;\n}\n\n// Since everything that happens in stableObjectReplacer benefits from being as\n// efficient as possible, we use a static function as the callback for\n// keys.every in order to test if the provided keys are already sorted without\n// allocating extra memory for a callback.\nfunction everyKeyInOrder(\n  key: string,\n  i: number,\n  keys: readonly string[]\n): boolean {\n  return i === 0 || keys[i - 1] <= key;\n}\n"]},"metadata":{},"sourceType":"module"}