{"ast":null,"code":"import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet } from \"./helpers.js\";\nconst EntryMethods = {\n  setDirty: true,\n  dispose: true,\n  forget: true // Fully remove parent Entry from LRU cache and computation graph\n\n};\nexport function dep(options) {\n  const depsByKey = new Map();\n  const subscribe = options && options.subscribe;\n\n  function depend(key) {\n    const parent = parentEntrySlot.getValue();\n\n    if (parent) {\n      let dep = depsByKey.get(key);\n\n      if (!dep) {\n        depsByKey.set(key, dep = new Set());\n      }\n\n      parent.dependOn(dep);\n\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep);\n        dep.unsubscribe = subscribe(key);\n      }\n    }\n  }\n\n  depend.dirty = function dirty(key, entryMethodName) {\n    const dep = depsByKey.get(key);\n\n    if (dep) {\n      const m = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\"; // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n      // because modifying a Set while iterating over it can cause elements in\n      // the Set to be removed from the Set before they've been iterated over.\n\n      arrayFromSet(dep).forEach(entry => entry[m]());\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n\n  return depend;\n}","map":{"version":3,"mappings":"AAEA,SAASA,eAAT,QAAgC,cAAhC;AACA,SACEC,cADF,EAGEC,gBAHF,EAIEC,YAJF,QAKQ,cALR;AAQA,MAAMC,YAAY,GAAG;AACnBC,UAAQ,EAAE,IADS;AAEnBC,SAAO,EAAE,IAFU;AAGnBC,QAAM,EAAE,IAHW,CAGH;;AAHG,CAArB;AAeA,OAAM,SAAUC,GAAV,CAAoBC,OAApB,EAEL;AACC,QAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;AACA,QAAMC,SAAS,GAAGH,OAAO,IAAIA,OAAO,CAACG,SAArC;;AAEA,WAASC,MAAT,CAAgBC,GAAhB,EAAyB;AACvB,UAAMC,MAAM,GAAGf,eAAe,CAACgB,QAAhB,EAAf;;AACA,QAAID,MAAJ,EAAY;AACV,UAAIP,GAAG,GAAGE,SAAS,CAACO,GAAV,CAAcH,GAAd,CAAV;;AACA,UAAI,CAACN,GAAL,EAAU;AACRE,iBAAS,CAACQ,GAAV,CAAcJ,GAAd,EAAmBN,GAAG,GAAG,IAAIW,GAAJ,EAAzB;AACD;;AACDJ,YAAM,CAACK,QAAP,CAAgBZ,GAAhB;;AACA,UAAI,OAAOI,SAAP,KAAqB,UAAzB,EAAqC;AACnCV,wBAAgB,CAACM,GAAD,CAAhB;AACAA,WAAG,CAACa,WAAJ,GAAkBT,SAAS,CAACE,GAAD,CAA3B;AACD;AACF;AACF;;AAEDD,QAAM,CAACS,KAAP,GAAe,SAASA,KAAT,CACbR,GADa,EAEbS,eAFa,EAEoB;AAEjC,UAAMf,GAAG,GAAGE,SAAS,CAACO,GAAV,CAAcH,GAAd,CAAZ;;AACA,QAAIN,GAAJ,EAAS;AACP,YAAMgB,CAAC,GACLD,eAAe,IACftB,cAAc,CAACwB,IAAf,CAAoBrB,YAApB,EAAkCmB,eAAlC,CAFyB,GAGvBA,eAHuB,GAGL,UAHtB,CADO,CAKP;AACA;AACA;;AACApB,kBAAY,CAACK,GAAD,CAAZ,CAAkBkB,OAAlB,CAA0BC,KAAK,IAAIA,KAAK,CAACH,CAAD,CAAL,EAAnC;AACAd,eAAS,CAACkB,MAAV,CAAiBd,GAAjB;AACAZ,sBAAgB,CAACM,GAAD,CAAhB;AACD;AACF,GAjBD;;AAmBA,SAAOK,MAAP;AACD","names":["parentEntrySlot","hasOwnProperty","maybeUnsubscribe","arrayFromSet","EntryMethods","setDirty","dispose","forget","dep","options","depsByKey","Map","subscribe","depend","key","parent","getValue","get","set","Set","dependOn","unsubscribe","dirty","entryMethodName","m","call","forEach","entry","delete"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/optimism/src/dep.ts"],"sourcesContent":["import { AnyEntry } from \"./entry.js\";\nimport { OptimisticWrapOptions } from \"./index.js\";\nimport { parentEntrySlot } from \"./context.js\";\nimport {\n  hasOwnProperty,\n  Unsubscribable,\n  maybeUnsubscribe,\n  arrayFromSet,\n } from \"./helpers.js\";\n\ntype EntryMethodName = keyof typeof EntryMethods;\nconst EntryMethods = {\n  setDirty: true, // Mark parent Entry as needing to be recomputed (default)\n  dispose: true,  // Detach parent Entry from parents and children, but leave in LRU cache\n  forget: true,   // Fully remove parent Entry from LRU cache and computation graph\n};\n\nexport type OptimisticDependencyFunction<TKey> =\n  ((key: TKey) => void) & {\n    dirty: (key: TKey, entryMethodName?: EntryMethodName) => void;\n  };\n\nexport type Dep<TKey> = Set<AnyEntry> & {\n  subscribe: OptimisticWrapOptions<[TKey]>[\"subscribe\"];\n} & Unsubscribable;\n\nexport function dep<TKey>(options?: {\n  subscribe: Dep<TKey>[\"subscribe\"];\n}) {\n  const depsByKey = new Map<TKey, Dep<TKey>>();\n  const subscribe = options && options.subscribe;\n\n  function depend(key: TKey) {\n    const parent = parentEntrySlot.getValue();\n    if (parent) {\n      let dep = depsByKey.get(key);\n      if (!dep) {\n        depsByKey.set(key, dep = new Set as Dep<TKey>);\n      }\n      parent.dependOn(dep);\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep);\n        dep.unsubscribe = subscribe(key);\n      }\n    }\n  }\n\n  depend.dirty = function dirty(\n    key: TKey,\n    entryMethodName?: EntryMethodName,\n  ) {\n    const dep = depsByKey.get(key);\n    if (dep) {\n      const m: EntryMethodName = (\n        entryMethodName &&\n        hasOwnProperty.call(EntryMethods, entryMethodName)\n      ) ? entryMethodName : \"setDirty\";\n      // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n      // because modifying a Set while iterating over it can cause elements in\n      // the Set to be removed from the Set before they've been iterated over.\n      arrayFromSet(dep).forEach(entry => entry[m]());\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n\n  return depend as OptimisticDependencyFunction<TKey>;\n}\n"]},"metadata":{},"sourceType":"module"}