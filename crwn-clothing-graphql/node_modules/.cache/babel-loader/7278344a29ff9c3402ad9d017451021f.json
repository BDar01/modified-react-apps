{"ast":null,"code":"// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null); // Useful for processing arguments objects as well as arrays.\n\n\nconst {\n  forEach,\n  slice\n} = Array.prototype;\nconst {\n  hasOwnProperty\n} = Object.prototype;\nexport class Trie {\n  constructor() {\n    let weakness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let makeData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMakeData;\n    this.weakness = weakness;\n    this.makeData = makeData;\n  }\n\n  lookup() {\n    return this.lookupArray(arguments);\n  }\n\n  lookupArray(array) {\n    let node = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return hasOwnProperty.call(node, \"data\") ? node.data : node.data = this.makeData(slice.call(array));\n  }\n\n  peek() {\n    return this.peekArray(arguments);\n  }\n\n  peekArray(array) {\n    let node = this;\n\n    for (let i = 0, len = array.length; node && i < len; ++i) {\n      const map = node.mapFor(array[i], false);\n      node = map && map.get(array[i]);\n    }\n\n    return node && node.data;\n  }\n\n  remove() {\n    return this.removeArray(arguments);\n  }\n\n  removeArray(array) {\n    let data;\n\n    if (array.length) {\n      const head = array[0];\n      const map = this.mapFor(head, false);\n      const child = map && map.get(head);\n\n      if (child) {\n        data = child.removeArray(slice.call(array, 1));\n\n        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n          map.delete(head);\n        }\n      }\n    } else {\n      data = this.data;\n      delete this.data;\n    }\n\n    return data;\n  }\n\n  getChildTrie(key) {\n    const map = this.mapFor(key, true);\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));\n    return child;\n  }\n\n  mapFor(key, create) {\n    return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = new WeakMap() : void 0) : this.strong || (create ? this.strong = new Map() : void 0);\n  }\n\n}\n\nfunction isObjRef(value) {\n  switch (typeof value) {\n    case \"object\":\n      if (value === null) break;\n    // Fall through to return true...\n\n    case \"function\":\n      return true;\n  }\n\n  return false;\n}","map":{"version":3,"mappings":"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","names":["defaultMakeData","Object","create","forEach","slice","Array","prototype","hasOwnProperty","Trie","constructor","weakness","makeData","lookup","lookupArray","arguments","array","node","call","key","getChildTrie","data","peek","peekArray","i","len","length","map","mapFor","get","remove","removeArray","head","child","weak","strong","size","delete","set","isObjRef","WeakMap","Map","value"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@wry/trie/src/index.ts"],"sourcesContent":["// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\n\nexport class Trie<Data> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, Trie<Data>>;\n  private strong?: Map<any, Trie<Data>>;\n  private data?: Data;\n\n  constructor(\n    private weakness = true,\n    private makeData: (array: any[]) => Data = defaultMakeData,\n  ) {}\n\n  public lookup<T extends any[]>(...array: T): Data;\n  public lookup(): Data {\n    return this.lookupArray(arguments);\n  }\n\n  public lookupArray<T extends IArguments | any[]>(array: T): Data {\n    let node: Trie<Data> = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return hasOwnProperty.call(node, \"data\")\n      ? node.data as Data\n      : node.data = this.makeData(slice.call(array));\n  }\n\n  public peek<T extends any[]>(...array: T): Data | undefined;\n  public peek(): Data | undefined {\n    return this.peekArray(arguments);\n  }\n\n  public peekArray<T extends IArguments | any[]>(array: T): Data | undefined {\n    let node: Trie<Data> | undefined = this;\n\n    for (let i = 0, len = array.length; node && i < len; ++i) {\n      const map = node.mapFor(array[i], false);\n      node = map && map.get(array[i]);\n    }\n\n    return node && node.data;\n  }\n\n  public remove(...array: any[]): Data | undefined;\n  public remove(): Data | undefined {\n    return this.removeArray(arguments);\n  }\n\n  public removeArray<T extends IArguments | any[]>(array: T): Data | undefined {\n    let data: Data | undefined;\n\n    if (array.length) {\n      const head = array[0];\n      const map = this.mapFor(head, false);\n      const child = map && map.get(head);\n      if (child) {\n        data = child.removeArray(slice.call(array, 1));\n        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n          map.delete(head);\n        }\n      }\n    } else {\n      data = this.data;\n      delete this.data;\n    }\n\n    return data;\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.mapFor(key, true)!;\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie<Data>(this.weakness, this.makeData));\n    return child;\n  }\n\n  private mapFor(key: any, create: boolean): Trie<Data>[\"weak\" | \"strong\"] | undefined {\n    return this.weakness && isObjRef(key)\n      ? this.weak || (create ? this.weak = new WeakMap : void 0)\n      : this.strong || (create ? this.strong = new Map : void 0);\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}