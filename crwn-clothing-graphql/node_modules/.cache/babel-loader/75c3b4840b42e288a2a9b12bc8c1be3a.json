{"ast":null,"code":"import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport { WeakCache } from \"@wry/caches\";\nimport { wrap } from \"optimism\";\nimport { cacheSizes } from \"../caching/index.js\";\n\nfunction identity(document) {\n  return document;\n}\n\nvar DocumentTransform =\n/** @class */\nfunction () {\n  function DocumentTransform(transform, options) {\n    if (options === void 0) {\n      options = Object.create(null);\n    }\n\n    this.resultCache = canUseWeakSet ? new WeakSet() : new Set();\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n\n    this.cached = options.cache !== false;\n    this.resetCache();\n  } // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n\n\n  DocumentTransform.prototype.getCacheKey = function (document) {\n    return [document];\n  };\n\n  DocumentTransform.identity = function () {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, {\n      cache: false\n    });\n  };\n\n  DocumentTransform.split = function (predicate, left, right) {\n    if (right === void 0) {\n      right = DocumentTransform.identity();\n    }\n\n    return Object.assign(new DocumentTransform(function (document) {\n      var documentTransform = predicate(document) ? left : right;\n      return documentTransform.transformDocument(document);\n    }, // Reasonably assume both `left` and `right` transforms handle their own caching\n    {\n      cache: false\n    }), {\n      left: left,\n      right: right\n    });\n  };\n  /**\n   * Resets the internal cache of this transform, if it has one.\n   */\n\n\n  DocumentTransform.prototype.resetCache = function () {\n    var _this = this;\n\n    if (this.cached) {\n      var stableCacheKeys_1 = new Trie(canUseWeakMap);\n      this.performWork = wrap(DocumentTransform.prototype.performWork.bind(this), {\n        makeCacheKey: function (document) {\n          var cacheKeys = _this.getCacheKey(document);\n\n          if (cacheKeys) {\n            invariant(Array.isArray(cacheKeys), 77);\n            return stableCacheKeys_1.lookupArray(cacheKeys);\n          }\n        },\n        max: cacheSizes[\"documentTransform.cache\"],\n        cache: WeakCache\n      });\n    }\n  };\n\n  DocumentTransform.prototype.performWork = function (document) {\n    checkDocument(document);\n    return this.transform(document);\n  };\n\n  DocumentTransform.prototype.transformDocument = function (document) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    var transformedDocument = this.performWork(document);\n    this.resultCache.add(transformedDocument);\n    return transformedDocument;\n  };\n\n  DocumentTransform.prototype.concat = function (otherTransform) {\n    var _this = this;\n\n    return Object.assign(new DocumentTransform(function (document) {\n      return otherTransform.transformDocument(_this.transformDocument(document));\n    }, // Reasonably assume both transforms handle their own caching\n    {\n      cache: false\n    }), {\n      left: this,\n      right: otherTransform\n    });\n  };\n\n  return DocumentTransform;\n}();\n\nexport { DocumentTransform };","map":{"version":3,"mappings":"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","names":["Trie","canUseWeakMap","canUseWeakSet","checkDocument","invariant","WeakCache","wrap","cacheSizes","identity","document","transform","options","Object","create","WeakSet","Set","getCacheKey","cached","cache","resetCache","DocumentTransform","predicate","left","right","assign","documentTransform","transformDocument","stableCacheKeys_1","performWork","prototype","bind","makeCacheKey","cacheKeys","_this","Array","isArray","lookupArray","max","resultCache","has","transformedDocument","add","otherTransform"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/utilities/graphql/DocumentTransform.ts"],"sourcesContent":["import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\nimport { WeakCache } from \"@wry/caches\";\nimport { wrap } from \"optimism\";\nimport { cacheSizes } from \"../caching/index.js\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  /**\n   * Determines whether to cache the transformed GraphQL document. Caching can speed up repeated calls to the document transform for the same input document. Set to `false` to completely disable caching for the document transform. When disabled, this option takes precedence over the [`getCacheKey`](#getcachekey) option.\n   *\n   * The default value is `true`.\n   */\n  cache?: boolean;\n  /**\n   * Defines a custom cache key for a GraphQL document that will determine whether to re-run the document transform when given the same input GraphQL document. Returns an array that defines the cache key. Return `undefined` to disable caching for that GraphQL document.\n   *\n   * > **Note:** The items in the array may be any type, but also need to be referentially stable to guarantee a stable cache key.\n   *\n   * The default implementation of this function returns the `document` as the cache key.\n   */\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n  private cached: boolean;\n\n  private readonly resultCache =\n    canUseWeakSet ? new WeakSet<DocumentNode>() : new Set<DocumentNode>();\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          const documentTransform = predicate(document) ? left : right;\n\n          return documentTransform.transformDocument(document);\n        },\n        // Reasonably assume both `left` and `right` transforms handle their own caching\n        { cache: false }\n      ),\n      { left, right }\n    );\n  }\n\n  constructor(\n    transform: TransformFn,\n    options: DocumentTransformOptions = Object.create(null)\n  ) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n    this.cached = options.cache !== false;\n\n    this.resetCache();\n  }\n\n  /**\n   * Resets the internal cache of this transform, if it has one.\n   */\n  resetCache() {\n    if (this.cached) {\n      const stableCacheKeys = new Trie<WeakKey>(canUseWeakMap);\n      this.performWork = wrap(\n        DocumentTransform.prototype.performWork.bind(this),\n        {\n          makeCacheKey: (document) => {\n            const cacheKeys = this.getCacheKey(document);\n            if (cacheKeys) {\n              invariant(\n                Array.isArray(cacheKeys),\n                \"`getCacheKey` must return an array or undefined\"\n              );\n              return stableCacheKeys.lookupArray(cacheKeys);\n            }\n          },\n          max: cacheSizes[\"documentTransform.cache\"],\n          cache: WeakCache<any, any>,\n        }\n      );\n    }\n  }\n\n  private performWork(document: DocumentNode) {\n    checkDocument(document);\n    return this.transform(document);\n  }\n\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const transformedDocument = this.performWork(document);\n\n    this.resultCache.add(transformedDocument);\n\n    return transformedDocument;\n  }\n\n  concat(otherTransform: DocumentTransform): DocumentTransform {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          return otherTransform.transformDocument(\n            this.transformDocument(document)\n          );\n        },\n        // Reasonably assume both transforms handle their own caching\n        { cache: false }\n      ),\n      {\n        left: this,\n        right: otherTransform,\n      }\n    );\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly left?: DocumentTransform;\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly right?: DocumentTransform;\n}\n"]},"metadata":{},"sourceType":"module"}