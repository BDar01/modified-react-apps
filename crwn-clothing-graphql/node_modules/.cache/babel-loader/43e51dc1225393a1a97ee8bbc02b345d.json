{"ast":null,"code":"import * as React from \"rehackt\";\nimport { assertWrappedQueryRef, getWrappedPromise, unwrapQueryRef, updateWrappedQueryRef } from \"../internal/index.js\";\nimport { __use, wrapHook } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nexport function useReadQuery(queryRef) {\n  var unwrapped = unwrapQueryRef(queryRef);\n  return wrapHook(\"useReadQuery\", _useReadQuery, unwrapped ? unwrapped[\"observable\"] // in the case of a \"transported\" queryRef object, we need to use the\n  // client that's available to us at the current position in the React tree\n  // that ApolloClient will then have the job to recreate a real queryRef from\n  // the transported object\n  // This is just a context read - it's fine to do this conditionally.\n  // This hook wrapper also shouldn't be optimized by React Compiler.\n  // eslint-disable-next-line react-compiler/react-compiler\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  : useApolloClient())(queryRef);\n}\n\nfunction _useReadQuery(queryRef) {\n  assertWrappedQueryRef(queryRef);\n  var internalQueryRef = React.useMemo(function () {\n    return unwrapQueryRef(queryRef);\n  }, [queryRef]);\n  var getPromise = React.useCallback(function () {\n    return getWrappedPromise(queryRef);\n  }, [queryRef]);\n\n  if (internalQueryRef.disposed) {\n    internalQueryRef.reinitialize();\n    updateWrappedQueryRef(queryRef, internalQueryRef.promise);\n  }\n\n  React.useEffect(function () {\n    return internalQueryRef.retain();\n  }, [internalQueryRef]);\n  var promise = useSyncExternalStore(React.useCallback(function (forceUpdate) {\n    return internalQueryRef.listen(function (promise) {\n      updateWrappedQueryRef(queryRef, promise);\n      forceUpdate();\n    });\n  }, [internalQueryRef, queryRef]), getPromise, getPromise);\n\n  var result = __use(promise);\n\n  return React.useMemo(function () {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result)\n    };\n  }, [result]);\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,SAAvB;AACA,SACEC,qBADF,EAEEC,iBAFF,EAGEC,cAHF,EAIEC,qBAJF,QAKO,sBALP;AAOA,SAASC,KAAT,EAAgBC,QAAhB,QAAgC,qBAAhC;AACA,SAASC,aAAT,QAA8B,uBAA9B;AACA,SAASC,oBAAT,QAAqC,2BAArC;AAGA,SAASC,eAAT,QAAgC,sBAAhC;AA4BA,OAAM,SAAUC,YAAV,CACJC,QADI,EACqB;AAEzB,MAAMC,SAAS,GAAGT,cAAc,CAACQ,QAAD,CAAhC;AAEA,SAAOL,QAAQ,CACb,cADa,EAEbO,aAFa,EAGbD,SAAS,GACPA,SAAS,CAAC,YAAD,CADF,CAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATO,IAUPH,eAAe,EAbJ,CAAR,CAcLE,QAdK,CAAP;AAeD;;AAED,SAASE,aAAT,CACEF,QADF,EAC2B;AAEzBV,uBAAqB,CAACU,QAAD,CAArB;AACA,MAAMG,gBAAgB,GAAGd,KAAK,CAACe,OAAN,CACvB;AAAM,yBAAc,CAACJ,QAAD,CAAd;AAAwB,GADP,EAEvB,CAACA,QAAD,CAFuB,CAAzB;AAKA,MAAMK,UAAU,GAAGhB,KAAK,CAACiB,WAAN,CACjB;AAAM,4BAAiB,CAACN,QAAD,CAAjB;AAA2B,GADhB,EAEjB,CAACA,QAAD,CAFiB,CAAnB;;AAKA,MAAIG,gBAAgB,CAACI,QAArB,EAA+B;AAC7BJ,oBAAgB,CAACK,YAAjB;AACAf,yBAAqB,CAACO,QAAD,EAAWG,gBAAgB,CAACM,OAA5B,CAArB;AACD;;AAEDpB,OAAK,CAACqB,SAAN,CAAgB;AAAM,2BAAgB,CAACC,MAAjB;AAAyB,GAA/C,EAAiD,CAACR,gBAAD,CAAjD;AAEA,MAAMM,OAAO,GAAGZ,oBAAoB,CAClCR,KAAK,CAACiB,WAAN,CACE,UAACM,WAAD,EAAY;AACV,WAAOT,gBAAgB,CAACU,MAAjB,CAAwB,UAACJ,OAAD,EAAQ;AACrChB,2BAAqB,CAACO,QAAD,EAAWS,OAAX,CAArB;AACAG,iBAAW;AACZ,KAHM,CAAP;AAID,GANH,EAOE,CAACT,gBAAD,EAAmBH,QAAnB,CAPF,CADkC,EAUlCK,UAVkC,EAWlCA,UAXkC,CAApC;;AAcA,MAAMS,MAAM,GAAGpB,KAAK,CAACe,OAAD,CAApB;;AAEA,SAAOpB,KAAK,CAACe,OAAN,CAAc;AACnB,WAAO;AACLW,UAAI,EAAED,MAAM,CAACC,IADR;AAELC,mBAAa,EAAEF,MAAM,CAACE,aAFjB;AAGLC,WAAK,EAAErB,aAAa,CAACkB,MAAD;AAHf,KAAP;AAKD,GANM,EAMJ,CAACA,MAAD,CANI,CAAP;AAOD","names":["React","assertWrappedQueryRef","getWrappedPromise","unwrapQueryRef","updateWrappedQueryRef","__use","wrapHook","toApolloError","useSyncExternalStore","useApolloClient","useReadQuery","queryRef","unwrapped","_useReadQuery","internalQueryRef","useMemo","getPromise","useCallback","disposed","reinitialize","promise","useEffect","retain","forceUpdate","listen","result","data","networkStatus","error"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/react/hooks/useReadQuery.ts"],"sourcesContent":["import * as React from \"rehackt\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n} from \"../internal/index.js\";\nimport type { QueryRef } from \"../internal/index.js\";\nimport { __use, wrapHook } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport type { ApolloError } from \"../../errors/index.js\";\nimport type { NetworkStatus } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport type { MaybeMasked } from \"../../masking/index.js\";\n\nexport interface UseReadQueryResult<TData = unknown> {\n  /**\n   * An object containing the result of your GraphQL query after it completes.\n   *\n   * This value might be `undefined` if a query results in one or more errors\n   * (depending on the query's `errorPolicy`).\n   */\n  data: MaybeMasked<TData>;\n  /**\n   * If the query produces one or more errors, this object contains either an\n   * array of `graphQLErrors` or a single `networkError`. Otherwise, this value\n   * is `undefined`.\n   *\n   * This property can be ignored when using the default `errorPolicy` or an\n   * `errorPolicy` of `none`. The hook will throw the error instead of setting\n   * this property.\n   */\n  error: ApolloError | undefined;\n  /**\n   * A number indicating the current network state of the query's associated\n   * request. {@link https://github.com/apollographql/apollo-client/blob/d96f4578f89b933c281bb775a39503f6cdb59ee8/src/core/networkStatus.ts#L4 | See possible values}.\n   */\n  networkStatus: NetworkStatus;\n}\n\nexport function useReadQuery<TData>(\n  queryRef: QueryRef<TData>\n): UseReadQueryResult<TData> {\n  const unwrapped = unwrapQueryRef(queryRef);\n\n  return wrapHook(\n    \"useReadQuery\",\n    _useReadQuery,\n    unwrapped ?\n      unwrapped[\"observable\"]\n      // in the case of a \"transported\" queryRef object, we need to use the\n      // client that's available to us at the current position in the React tree\n      // that ApolloClient will then have the job to recreate a real queryRef from\n      // the transported object\n      // This is just a context read - it's fine to do this conditionally.\n      // This hook wrapper also shouldn't be optimized by React Compiler.\n      // eslint-disable-next-line react-compiler/react-compiler\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n    : useApolloClient()\n  )(queryRef);\n}\n\nfunction _useReadQuery<TData>(\n  queryRef: QueryRef<TData>\n): UseReadQueryResult<TData> {\n  assertWrappedQueryRef(queryRef);\n  const internalQueryRef = React.useMemo(\n    () => unwrapQueryRef(queryRef),\n    [queryRef]\n  );\n\n  const getPromise = React.useCallback(\n    () => getWrappedPromise(queryRef),\n    [queryRef]\n  );\n\n  if (internalQueryRef.disposed) {\n    internalQueryRef.reinitialize();\n    updateWrappedQueryRef(queryRef, internalQueryRef.promise);\n  }\n\n  React.useEffect(() => internalQueryRef.retain(), [internalQueryRef]);\n\n  const promise = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        return internalQueryRef.listen((promise) => {\n          updateWrappedQueryRef(queryRef, promise);\n          forceUpdate();\n        });\n      },\n      [internalQueryRef, queryRef]\n    ),\n    getPromise,\n    getPromise\n  );\n\n  const result = __use(promise);\n\n  return React.useMemo(() => {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result),\n    };\n  }, [result]);\n}\n"]},"metadata":{},"sourceType":"module"}