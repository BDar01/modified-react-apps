{"ast":null,"code":"import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { getNamedType, isInterfaceType, isLeafType, isListType, isNonNullType, isObjectType } from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(_ref => {\n      let [responseName, subReason] = _ref;\n      return `subfields \"${responseName}\" conflict because ` + reasonMessage(subReason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when fields and a fragment or two fragments are compared\n  // \"between\" each other for conflicts. Comparisons made be made many times,\n  // so memoizing this can dramatically improve the performance of this validator.\n  const comparedFieldsAndFragmentPairs = new OrderedPairSet();\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(new GraphQLError(`Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {\n          nodes: fields1.concat(fields2)\n        }));\n      }\n    }\n\n  };\n}\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\n\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  // Memoize so the fields and fragments are not compared for conflicts more\n  // than once.\n  if (comparedFieldsAndFragmentPairs.has(fieldMap, fragmentName, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFieldsAndFragmentPairs.add(fieldMap, fragmentName, areMutuallyExclusive);\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);\n  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, `\"${name1}\" and \"${name2}\" are different fields`], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n\n    if (!sameArguments(node1, node2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, `they return conflicting types \"${inspect(type1)}\" and \"${inspect(type2)}\"`], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(node1, node2) {\n  const args1 = node1.arguments;\n  const args2 = node2.arguments;\n\n  if (args1 === undefined || args1.length === 0) {\n    return args2 === undefined || args2.length === 0;\n  }\n\n  if (args2 === undefined || args2.length === 0) {\n    return false;\n  }\n  /* c8 ignore next */\n\n\n  if (args1.length !== args2.length) {\n    /* c8 ignore next */\n    return false;\n    /* c8 ignore next */\n  }\n\n  const values2 = new Map(args2.map(_ref2 => {\n    let {\n      name,\n      value\n    } = _ref2;\n    return [name.value, value];\n  }));\n  return args1.every(arg1 => {\n    const value1 = arg1.value;\n    const value2 = values2.get(arg1.name.value);\n\n    if (value2 === undefined) {\n      return false;\n    }\n\n    return stringifyValue(value1) === stringifyValue(value2);\n  });\n}\n\nfunction stringifyValue(value) {\n  return print(sortValueNode(value));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          const fieldName = selection.name.value;\n          let fieldDef;\n\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            fieldDef = parentType.getFields()[fieldName];\n          }\n\n          const responseName = selection.alias ? selection.alias.value : fieldName;\n\n          if (!nodeAndDefs[responseName]) {\n            nodeAndDefs[responseName] = [];\n          }\n\n          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          const typeCondition = selection.typeCondition;\n          const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n          break;\n        }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(_ref3 => {\n      let [reason] = _ref3;\n      return reason;\n    })], [node1, ...conflicts.map(_ref4 => {\n      let [, fields1] = _ref4;\n      return fields1;\n    }).flat()], [node2, ...conflicts.map(_ref5 => {\n      let [,, fields2] = _ref5;\n      return fields2;\n    }).flat()]];\n  }\n}\n/**\n * A way to keep track of pairs of things where the ordering of the pair\n * matters.\n *\n * Provides a third argument for has/set to allow flagging the pair as\n * weakly or strongly present within the collection.\n */\n\n\nclass OrderedPairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, weaklyPresent) {\n    var _this$_data$get;\n\n    const result = (_this$_data$get = this._data.get(a)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b);\n\n    if (result === undefined) {\n      return false;\n    }\n\n    return weaklyPresent ? true : weaklyPresent === result;\n  }\n\n  add(a, b, weaklyPresent) {\n    const map = this._data.get(a);\n\n    if (map === undefined) {\n      this._data.set(a, new Map([[b, weaklyPresent]]));\n    } else {\n      map.set(b, weaklyPresent);\n    }\n  }\n\n}\n/**\n * A way to keep track of pairs of similar things when the ordering of the pair\n * does not matter.\n */\n\n\nclass PairSet {\n  constructor() {\n    this._orderedPairSet = new OrderedPairSet();\n  }\n\n  has(a, b, weaklyPresent) {\n    return a < b ? this._orderedPairSet.has(a, b, weaklyPresent) : this._orderedPairSet.has(b, a, weaklyPresent);\n  }\n\n  add(a, b, weaklyPresent) {\n    if (a < b) {\n      this._orderedPairSet.add(a, b, weaklyPresent);\n    } else {\n      this._orderedPairSet.add(b, a, weaklyPresent);\n    }\n  }\n\n}","map":{"version":3,"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"names":["inspect","GraphQLError","Kind","print","getNamedType","isInterfaceType","isLeafType","isListType","isNonNullType","isObjectType","sortValueNode","typeFromAST","reasonMessage","reason","Array","isArray","map","responseName","subReason","join","OverlappingFieldsCanBeMergedRule","context","comparedFieldsAndFragmentPairs","OrderedPairSet","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","fields1","fields2","reasonMsg","reportError","nodes","concat","parentType","fieldMap","fragmentNames","getFieldsAndFragmentNames","collectConflictsWithin","length","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","has","add","fragment","getFragment","fieldMap2","referencedFragmentNames","getReferencedFieldsAndFragmentNames","collectConflictsBetween","referencedFragmentName","fragmentName1","fragmentName2","fragment1","fragment2","fieldMap1","referencedFragmentNames1","referencedFragmentNames2","referencedFragmentName2","referencedFragmentName1","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","fragmentNames1","fragmentNames2","fields","Object","entries","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","field1","field2","node1","def1","node2","def2","name1","name","value","name2","sameArguments","type1","type","type2","doTypesConflict","subfieldConflicts","args1","arguments","args2","undefined","values2","every","arg1","value1","value2","get","stringifyValue","ofType","cached","nodeAndDefs","create","_collectFieldsAndFragmentNames","result","keys","set","fragmentType","getSchema","typeCondition","selection","selections","kind","FIELD","fieldName","fieldDef","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","flat","constructor","_data","a","b","weaklyPresent","_this$_data$get","_orderedPairSet"],"mappings":"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","sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when fields and a fragment or two fragments are compared\n  // \"between\" each other for conflicts. Comparisons made be made many times,\n  // so memoizing this can dramatically improve the performance of this validator.\n  const comparedFieldsAndFragmentPairs = new OrderedPairSet();\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFieldsAndFragmentPairs,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  // Memoize so the fields and fragments are not compared for conflicts more\n  // than once.\n  if (\n    comparedFieldsAndFragmentPairs.has(\n      fieldMap,\n      fragmentName,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFieldsAndFragmentPairs.add(\n    fieldMap,\n    fragmentName,\n    areMutuallyExclusive,\n  );\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFieldsAndFragmentPairs,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFieldsAndFragmentPairs,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (!sameArguments(node1, node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(node1, node2) {\n  const args1 = node1.arguments;\n  const args2 = node2.arguments;\n\n  if (args1 === undefined || args1.length === 0) {\n    return args2 === undefined || args2.length === 0;\n  }\n\n  if (args2 === undefined || args2.length === 0) {\n    return false;\n  }\n  /* c8 ignore next */\n\n  if (args1.length !== args2.length) {\n    /* c8 ignore next */\n    return false;\n    /* c8 ignore next */\n  }\n\n  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));\n  return args1.every((arg1) => {\n    const value1 = arg1.value;\n    const value2 = values2.get(arg1.name.value);\n\n    if (value2 === undefined) {\n      return false;\n    }\n\n    return stringifyValue(value1) === stringifyValue(value2);\n  });\n}\n\nfunction stringifyValue(value) {\n  return print(sortValueNode(value));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things where the ordering of the pair\n * matters.\n *\n * Provides a third argument for has/set to allow flagging the pair as\n * weakly or strongly present within the collection.\n */\n\nclass OrderedPairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, weaklyPresent) {\n    var _this$_data$get;\n\n    const result =\n      (_this$_data$get = this._data.get(a)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(b);\n\n    if (result === undefined) {\n      return false;\n    }\n\n    return weaklyPresent ? true : weaklyPresent === result;\n  }\n\n  add(a, b, weaklyPresent) {\n    const map = this._data.get(a);\n\n    if (map === undefined) {\n      this._data.set(a, new Map([[b, weaklyPresent]]));\n    } else {\n      map.set(b, weaklyPresent);\n    }\n  }\n}\n/**\n * A way to keep track of pairs of similar things when the ordering of the pair\n * does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._orderedPairSet = new OrderedPairSet();\n  }\n\n  has(a, b, weaklyPresent) {\n    return a < b\n      ? this._orderedPairSet.has(a, b, weaklyPresent)\n      : this._orderedPairSet.has(b, a, weaklyPresent);\n  }\n\n  add(a, b, weaklyPresent) {\n    if (a < b) {\n      this._orderedPairSet.add(a, b, weaklyPresent);\n    } else {\n      this._orderedPairSet.add(b, a, weaklyPresent);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}