{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { createFulfilledPromise, createRejectedPromise } from \"../../../utilities/index.js\";\nimport { wrapPromiseWithState } from \"../../../utilities/index.js\";\nimport { invariant } from \"../../../utilities/globals/invariantWrappers.js\";\nvar QUERY_REFERENCE_SYMBOL = Symbol();\nvar PROMISE_SYMBOL = Symbol();\nexport function wrapQueryRef(internalQueryRef) {\n  var _a;\n\n  var ref = (_a = {\n    toPromise: function () {\n      // We avoid resolving this promise with the query data because we want to\n      // discourage using the server data directly from the queryRef. Instead,\n      // the data should be accessed through `useReadQuery`. When the server\n      // data is needed, its better to use `client.query()` directly.\n      //\n      // Here we resolve with the ref itself to make using this in React Router\n      // or TanStack Router `loader` functions a bit more ergonomic e.g.\n      //\n      // function loader() {\n      //   return { queryRef: await preloadQuery(query).toPromise() }\n      // }\n      return getWrappedPromise(ref).then(function () {\n        return ref;\n      });\n    }\n  }, _a[QUERY_REFERENCE_SYMBOL] = internalQueryRef, _a[PROMISE_SYMBOL] = internalQueryRef.promise, _a);\n  return ref;\n}\nexport function assertWrappedQueryRef(queryRef) {\n  invariant(!queryRef || QUERY_REFERENCE_SYMBOL in queryRef, 69);\n}\nexport function getWrappedPromise(queryRef) {\n  var internalQueryRef = unwrapQueryRef(queryRef);\n  return internalQueryRef.promise.status === \"fulfilled\" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL];\n}\nexport function unwrapQueryRef(queryRef) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\nexport function updateWrappedQueryRef(queryRef, promise) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\nvar OBSERVED_CHANGED_OPTIONS = [\"canonizeResults\", \"context\", \"errorPolicy\", \"fetchPolicy\", \"refetchWritePolicy\", \"returnPartialData\"];\n\nvar InternalQueryReference =\n/** @class */\nfunction () {\n  function InternalQueryReference(observable, options) {\n    var _this = this;\n\n    this.key = {};\n    this.listeners = new Set();\n    this.references = 0;\n    this.softReferences = 0;\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    this.setResult();\n    this.subscribeToQuery(); // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n\n    var startDisposeTimer = function () {\n      var _a;\n\n      if (!_this.references) {\n        _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n      }\n    }; // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n\n\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  Object.defineProperty(InternalQueryReference.prototype, \"disposed\", {\n    get: function () {\n      return this.subscription.closed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InternalQueryReference.prototype, \"watchQueryOptions\", {\n    get: function () {\n      return this.observable.options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InternalQueryReference.prototype.reinitialize = function () {\n    var observable = this.observable;\n    var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    var avoidNetworkRequests = originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n\n    try {\n      if (avoidNetworkRequests) {\n        observable.silentSetOptions({\n          fetchPolicy: \"standby\"\n        });\n      } else {\n        observable.resetLastResults();\n        observable.silentSetOptions({\n          fetchPolicy: \"cache-first\"\n        });\n      }\n\n      this.subscribeToQuery();\n\n      if (avoidNetworkRequests) {\n        return;\n      }\n\n      observable.resetDiff();\n      this.setResult();\n    } finally {\n      observable.silentSetOptions({\n        fetchPolicy: originalFetchPolicy\n      });\n    }\n  };\n\n  InternalQueryReference.prototype.retain = function () {\n    var _this = this;\n\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    var disposed = false;\n    return function () {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      _this.references--;\n      setTimeout(function () {\n        if (!_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n\n  InternalQueryReference.prototype.softRetain = function () {\n    var _this = this;\n\n    this.softReferences++;\n    var disposed = false;\n    return function () {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      _this.softReferences--;\n      setTimeout(function () {\n        if (!_this.softReferences && !_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n\n  InternalQueryReference.prototype.didChangeOptions = function (watchQueryOptions) {\n    var _this = this;\n\n    return OBSERVED_CHANGED_OPTIONS.some(function (option) {\n      return option in watchQueryOptions && !equal(_this.watchQueryOptions[option], watchQueryOptions[option]);\n    });\n  };\n\n  InternalQueryReference.prototype.applyOptions = function (watchQueryOptions) {\n    var _a = this.watchQueryOptions,\n        currentFetchPolicy = _a.fetchPolicy,\n        currentCanonizeResults = _a.canonizeResults; // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n\n    if (currentFetchPolicy === \"standby\" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  };\n\n  InternalQueryReference.prototype.listen = function (listener) {\n    var _this = this;\n\n    this.listeners.add(listener);\n    return function () {\n      _this.listeners.delete(listener);\n    };\n  };\n\n  InternalQueryReference.prototype.refetch = function (variables) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  };\n\n  InternalQueryReference.prototype.fetchMore = function (options) {\n    return this.initiateFetch(this.observable.fetchMore(options));\n  };\n\n  InternalQueryReference.prototype.dispose = function () {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  };\n\n  InternalQueryReference.prototype.onDispose = function () {// noop. overridable by options\n  };\n\n  InternalQueryReference.prototype.handleNext = function (result) {\n    var _a;\n\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n\n          this.result = result;\n          (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result);\n          break;\n        }\n\n      default:\n        {\n          // This occurs when switching to a result that is fully cached when this\n          // class is instantiated. ObservableQuery will run reobserve when\n          // subscribing, which delivers a result from the cache.\n          if (result.data === this.result.data && result.networkStatus === this.result.networkStatus) {\n            return;\n          } // Maintain the last successful `data` value if the next result does not\n          // have one.\n\n\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n\n          this.result = result;\n          this.promise = createFulfilledPromise(result);\n          this.deliver(this.promise);\n          break;\n        }\n    }\n  };\n\n  InternalQueryReference.prototype.handleError = function (error) {\n    var _a;\n\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);\n\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n          break;\n        }\n\n      default:\n        {\n          this.promise = createRejectedPromise(error);\n          this.deliver(this.promise);\n        }\n    }\n  };\n\n  InternalQueryReference.prototype.deliver = function (promise) {\n    this.listeners.forEach(function (listener) {\n      return listener(promise);\n    });\n  };\n\n  InternalQueryReference.prototype.initiateFetch = function (returnedPromise) {\n    var _this = this;\n\n    this.promise = this.createPendingPromise();\n    this.promise.catch(function () {}); // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n\n    returnedPromise.then(function () {\n      // In the case of `fetchMore`, this promise is resolved before a cache\n      // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n      // fetch policy and runs `cache.batch` in its `.then` handler. Because\n      // the timing is different, we accidentally run this update twice\n      // causing an additional re-render with the `fetchMore` result by\n      // itself. By wrapping in `setTimeout`, this should provide a short\n      // delay to allow the `QueryInfo.notify` handler to run before this\n      // promise is checked.\n      // See https://github.com/apollographql/apollo-client/issues/11315 for\n      // more information\n      setTimeout(function () {\n        var _a;\n\n        if (_this.promise.status === \"pending\") {\n          // Use the current result from the observable instead of the value\n          // resolved from the promise. This avoids issues in some cases where\n          // the raw resolved value should not be the emitted value, such as\n          // when a `fetchMore` call returns an empty array after it has\n          // reached the end of the list.\n          //\n          // See the following for more information:\n          // https://github.com/apollographql/apollo-client/issues/11642\n          _this.result = _this.observable.getCurrentResult();\n          (_a = _this.resolve) === null || _a === void 0 ? void 0 : _a.call(_this, _this.result);\n        }\n      });\n    }).catch(function (error) {\n      var _a;\n\n      return (_a = _this.reject) === null || _a === void 0 ? void 0 : _a.call(_this, error);\n    });\n    return returnedPromise;\n  };\n\n  InternalQueryReference.prototype.subscribeToQuery = function () {\n    var _this = this;\n\n    this.subscription = this.observable.filter(function (result) {\n      return !equal(result.data, {}) && !equal(result, _this.result);\n    }).subscribe(this.handleNext, this.handleError);\n  };\n\n  InternalQueryReference.prototype.setResult = function () {\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    var result = this.observable.getCurrentResult(false);\n\n    if (equal(result, this.result)) {\n      return;\n    }\n\n    this.result = result;\n    this.promise = result.data && (!result.partial || this.watchQueryOptions.returnPartialData) ? createFulfilledPromise(result) : this.createPendingPromise();\n  };\n\n  InternalQueryReference.prototype.createPendingPromise = function () {\n    var _this = this;\n\n    return wrapPromiseWithState(new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    }));\n  };\n\n  return InternalQueryReference;\n}();\n\nexport { InternalQueryReference };","map":{"version":3,"mappings":"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","names":["equal","createFulfilledPromise","createRejectedPromise","wrapPromiseWithState","invariant","QUERY_REFERENCE_SYMBOL","Symbol","PROMISE_SYMBOL","wrapQueryRef","internalQueryRef","ref","toPromise","getWrappedPromise","then","_a","promise","assertWrappedQueryRef","queryRef","unwrapQueryRef","status","updateWrappedQueryRef","OBSERVED_CHANGED_OPTIONS","observable","options","Set","handleNext","bind","handleError","dispose","onDispose","setResult","subscribeToQuery","startDisposeTimer","_this","references","autoDisposeTimeoutId","setTimeout","autoDisposeTimeoutMs","Object","InternalQueryReference","subscription","closed","originalFetchPolicy","watchQueryOptions","fetchPolicy","avoidNetworkRequests","silentSetOptions","resetLastResults","resetDiff","clearTimeout","disposed","softReferences","some","option","currentFetchPolicy","currentCanonizeResults","initiateFetch","reobserve","canonizeResults","result","__assign","getCurrentResult","listener","listeners","add","delete","variables","refetch","fetchMore","unsubscribe","data","resolve","networkStatus","deliver","error","resubscribeAfterError","reject","forEach","returnedPromise","createPendingPromise","catch","filter","subscribe","partial","returnPartialData","Promise"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/react/internal/cache/QueryReference.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  ObservableQuery,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../../core/index.js\";\nimport type {\n  ObservableSubscription,\n  PromiseWithState,\n} from \"../../../utilities/index.js\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n} from \"../../../utilities/index.js\";\nimport type { QueryKey } from \"./types.js\";\nimport { wrapPromiseWithState } from \"../../../utilities/index.js\";\nimport { invariant } from \"../../../utilities/globals/invariantWrappers.js\";\nimport type { MaybeMasked } from \"../../../masking/index.js\";\n\ntype QueryRefPromise<TData> = PromiseWithState<\n  ApolloQueryResult<MaybeMasked<TData>>\n>;\n\ntype Listener<TData> = (promise: QueryRefPromise<TData>) => void;\n\ntype FetchMoreOptions<TData> = Parameters<\n  ObservableQuery<TData>[\"fetchMore\"]\n>[0];\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol();\nconst PROMISE_SYMBOL: unique symbol = Symbol();\ndeclare const QUERY_REF_BRAND: unique symbol;\n/**\n * A `QueryReference` is an opaque object returned by `useBackgroundQuery`.\n * A child component reading the `QueryReference` via `useReadQuery` will\n * suspend until the promise resolves.\n */\nexport interface QueryRef<TData = unknown, TVariables = unknown> {\n  /** @internal */\n  [QUERY_REF_BRAND]?(variables: TVariables): TData;\n}\n\n/**\n * @internal\n * For usage in internal helpers only.\n */\ninterface WrappedQueryRef<TData = unknown, TVariables = unknown>\n  extends QueryRef<TData, TVariables> {\n  /** @internal */\n  readonly [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData>;\n  /** @internal */\n  [PROMISE_SYMBOL]: QueryRefPromise<TData>;\n  /** @internal */\n  toPromise?(): Promise<unknown>;\n}\n\n/**\n * @deprecated Please use the `QueryRef` interface instead of `QueryReference`.\n *\n * {@inheritDoc @apollo/client!QueryRef:interface}\n */\nexport interface QueryReference<TData = unknown, TVariables = unknown>\n  extends QueryRef<TData, TVariables> {\n  /**\n   * @deprecated Please use the `QueryRef` interface instead of `QueryReference`.\n   *\n   * {@inheritDoc @apollo/client!PreloadedQueryRef#toPromise:member(1)}\n   */\n  toPromise?: unknown;\n}\n\n/**\n * {@inheritDoc @apollo/client!QueryRef:interface}\n */\nexport interface PreloadedQueryRef<TData = unknown, TVariables = unknown>\n  extends QueryRef<TData, TVariables> {\n  /**\n   * A function that returns a promise that resolves when the query has finished\n   * loading. The promise resolves with the `QueryReference` itself.\n   *\n   * @remarks\n   * This method is useful for preloading queries in data loading routers, such\n   * as [React Router](https://reactrouter.com/en/main) or [TanStack Router](https://tanstack.com/router),\n   * to prevent routes from transitioning until the query has finished loading.\n   * `data` is not exposed on the promise to discourage using the data in\n   * `loader` functions and exposing it to your route components. Instead, we\n   * prefer you rely on `useReadQuery` to access the data to ensure your\n   * component can rerender with cache updates. If you need to access raw query\n   * data, use `client.query()` directly.\n   *\n   * @example\n   * Here's an example using React Router's `loader` function:\n   * ```ts\n   * import { createQueryPreloader } from \"@apollo/client\";\n   *\n   * const preloadQuery = createQueryPreloader(client);\n   *\n   * export async function loader() {\n   *   const queryRef = preloadQuery(GET_DOGS_QUERY);\n   *\n   *   return queryRef.toPromise();\n   * }\n   *\n   * export function RouteComponent() {\n   *   const queryRef = useLoaderData();\n   *   const { data } = useReadQuery(queryRef);\n   *\n   *   // ...\n   * }\n   * ```\n   *\n   * @since 3.9.0\n   */\n  toPromise(): Promise<PreloadedQueryRef<TData, TVariables>>;\n}\n\ninterface InternalQueryReferenceOptions {\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<TData, TVariables extends OperationVariables>(\n  internalQueryRef: InternalQueryReference<TData>\n) {\n  const ref: WrappedQueryRef<TData, TVariables> = {\n    toPromise() {\n      // We avoid resolving this promise with the query data because we want to\n      // discourage using the server data directly from the queryRef. Instead,\n      // the data should be accessed through `useReadQuery`. When the server\n      // data is needed, its better to use `client.query()` directly.\n      //\n      // Here we resolve with the ref itself to make using this in React Router\n      // or TanStack Router `loader` functions a bit more ergonomic e.g.\n      //\n      // function loader() {\n      //   return { queryRef: await preloadQuery(query).toPromise() }\n      // }\n      return getWrappedPromise(ref).then(() => ref);\n    },\n    [QUERY_REFERENCE_SYMBOL]: internalQueryRef,\n    [PROMISE_SYMBOL]: internalQueryRef.promise,\n  };\n\n  return ref;\n}\n\nexport function assertWrappedQueryRef<TData, TVariables>(\n  queryRef: QueryRef<TData, TVariables>\n): asserts queryRef is WrappedQueryRef<TData, TVariables>;\nexport function assertWrappedQueryRef<TData, TVariables>(\n  queryRef: QueryRef<TData, TVariables> | undefined | null\n): asserts queryRef is WrappedQueryRef<TData, TVariables> | undefined | null;\nexport function assertWrappedQueryRef<TData, TVariables>(\n  queryRef: QueryRef<TData, TVariables> | undefined | null\n) {\n  invariant(\n    !queryRef || QUERY_REFERENCE_SYMBOL in queryRef,\n    \"Expected a QueryRef object, but got something else instead.\"\n  );\n}\n\nexport function getWrappedPromise<TData>(\n  queryRef: WrappedQueryRef<TData, any>\n) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  return internalQueryRef.promise.status === \"fulfilled\" ?\n      internalQueryRef.promise\n    : queryRef[PROMISE_SYMBOL];\n}\n\nexport function unwrapQueryRef<TData>(\n  queryRef: WrappedQueryRef<TData>\n): InternalQueryReference<TData>;\nexport function unwrapQueryRef<TData>(\n  queryRef: Partial<WrappedQueryRef<TData>>\n): undefined | InternalQueryReference<TData>;\nexport function unwrapQueryRef<TData>(\n  queryRef: Partial<WrappedQueryRef<TData>>\n) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nexport function updateWrappedQueryRef<TData>(\n  queryRef: WrappedQueryRef<TData>,\n  promise: QueryRefPromise<TData>\n) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"canonizeResults\",\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<TData = unknown> {\n  public result!: ApolloQueryResult<MaybeMasked<TData>>;\n  public readonly key: QueryKey = {};\n  public readonly observable: ObservableQuery<TData>;\n\n  public promise!: QueryRefPromise<TData>;\n\n  private subscription!: ObservableSubscription;\n  private listeners = new Set<Listener<TData>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private resolve:\n    | ((result: ApolloQueryResult<MaybeMasked<TData>>) => void)\n    | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n  private softReferences = 0;\n\n  constructor(\n    observable: ObservableQuery<TData, any>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    this.setResult();\n    this.subscribeToQuery();\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get disposed() {\n    return this.subscription.closed;\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  reinitialize() {\n    const { observable } = this;\n\n    const originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    const avoidNetworkRequests =\n      originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n\n    try {\n      if (avoidNetworkRequests) {\n        observable.silentSetOptions({ fetchPolicy: \"standby\" });\n      } else {\n        observable.resetLastResults();\n        observable.silentSetOptions({ fetchPolicy: \"cache-first\" });\n      }\n\n      this.subscribeToQuery();\n\n      if (avoidNetworkRequests) {\n        return;\n      }\n\n      observable.resetDiff();\n      this.setResult();\n    } finally {\n      observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });\n    }\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  softRetain() {\n    this.softReferences++;\n    let disposed = false;\n\n    return () => {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.softReferences--;\n      setTimeout(() => {\n        if (!this.softReferences && !this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        option in watchQueryOptions &&\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy,\n      canonizeResults: currentCanonizeResults,\n    } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = { ...this.result, ...this.observable.getCurrentResult() };\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: FetchMoreOptions<TData>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(result: ApolloQueryResult<MaybeMasked<TData>>) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n        this.result = result;\n        this.resolve?.(result);\n        break;\n      }\n      default: {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (\n          result.data === this.result.data &&\n          result.networkStatus === this.result.networkStatus\n        ) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        this.result = result;\n        this.promise = createFulfilledPromise(result);\n        this.deliver(this.promise);\n        break;\n      }\n    }\n  }\n\n  private handleError(error: ApolloError) {\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(\n      this.handleNext,\n      this.handleError\n    );\n\n    switch (this.promise.status) {\n      case \"pending\": {\n        this.reject?.(error);\n        break;\n      }\n      default: {\n        this.promise = createRejectedPromise(error);\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private deliver(promise: QueryRefPromise<TData>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(\n    returnedPromise: Promise<ApolloQueryResult<MaybeMasked<TData>>>\n  ) {\n    this.promise = this.createPendingPromise();\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then(() => {\n        // In the case of `fetchMore`, this promise is resolved before a cache\n        // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n        // fetch policy and runs `cache.batch` in its `.then` handler. Because\n        // the timing is different, we accidentally run this update twice\n        // causing an additional re-render with the `fetchMore` result by\n        // itself. By wrapping in `setTimeout`, this should provide a short\n        // delay to allow the `QueryInfo.notify` handler to run before this\n        // promise is checked.\n        // See https://github.com/apollographql/apollo-client/issues/11315 for\n        // more information\n        setTimeout(() => {\n          if (this.promise.status === \"pending\") {\n            // Use the current result from the observable instead of the value\n            // resolved from the promise. This avoids issues in some cases where\n            // the raw resolved value should not be the emitted value, such as\n            // when a `fetchMore` call returns an empty array after it has\n            // reached the end of the list.\n            //\n            // See the following for more information:\n            // https://github.com/apollographql/apollo-client/issues/11642\n            this.result = this.observable.getCurrentResult();\n            this.resolve?.(this.result);\n          }\n        });\n      })\n      .catch((error) => this.reject?.(error));\n\n    return returnedPromise;\n  }\n\n  private subscribeToQuery() {\n    this.subscription = this.observable\n      .filter(\n        (result) => !equal(result.data, {}) && !equal(result, this.result)\n      )\n      .subscribe(this.handleNext, this.handleError);\n  }\n\n  private setResult() {\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    const result = this.observable.getCurrentResult(false);\n\n    if (equal(result, this.result)) {\n      return;\n    }\n\n    this.result = result;\n    this.promise =\n      (\n        result.data &&\n        (!result.partial || this.watchQueryOptions.returnPartialData)\n      ) ?\n        createFulfilledPromise(result)\n      : this.createPendingPromise();\n  }\n\n  private createPendingPromise() {\n    return wrapPromiseWithState(\n      new Promise<ApolloQueryResult<MaybeMasked<TData>>>((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      })\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}