{"ast":null,"code":"import * as React from \"rehackt\";\nimport { assertWrappedQueryRef, getWrappedPromise, unwrapQueryRef, updateWrappedQueryRef, wrapQueryRef } from \"../internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapHook } from \"./internal/index.js\";\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n * @since 3.9.0\n * @param queryRef - A `QueryRef` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\n\nexport function useQueryRefHandlers(queryRef) {\n  var unwrapped = unwrapQueryRef(queryRef);\n  return wrapHook(\"useQueryRefHandlers\", _useQueryRefHandlers, unwrapped ? unwrapped[\"observable\"] // in the case of a \"transported\" queryRef object, we need to use the\n  // client that's available to us at the current position in the React tree\n  // that ApolloClient will then have the job to recreate a real queryRef from\n  // the transported object\n  // This is just a context read - it's fine to do this conditionally.\n  // This hook wrapper also shouldn't be optimized by React Compiler.\n  // eslint-disable-next-line react-compiler/react-compiler\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  : useApolloClient())(queryRef);\n}\n\nfunction _useQueryRefHandlers(queryRef) {\n  assertWrappedQueryRef(queryRef);\n\n  var _a = React.useState(queryRef),\n      previousQueryRef = _a[0],\n      setPreviousQueryRef = _a[1];\n\n  var _b = React.useState(queryRef),\n      wrappedQueryRef = _b[0],\n      setWrappedQueryRef = _b[1];\n\n  var internalQueryRef = unwrapQueryRef(queryRef); // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n\n  var refetch = React.useCallback(function (variables) {\n    var promise = internalQueryRef.refetch(variables);\n    setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n    return promise;\n  }, [internalQueryRef]);\n  var fetchMore = React.useCallback(function (options) {\n    var promise = internalQueryRef.fetchMore(options);\n    setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n    return promise;\n  }, [internalQueryRef]);\n  return {\n    refetch: refetch,\n    fetchMore: fetchMore,\n    subscribeToMore: internalQueryRef.observable.subscribeToMore\n  };\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,SAAvB;AACA,SACEC,qBADF,EAEEC,iBAFF,EAGEC,cAHF,EAIEC,qBAJF,EAKEC,YALF,QAMO,sBANP;AAeA,SAASC,eAAT,QAAgC,sBAAhC;AACA,SAASC,QAAT,QAAyB,qBAAzB;AAcA;;;;;;;;;;;;;;;;;;;;AAmBA,OAAM,SAAUC,mBAAV,CAIJC,QAJI,EAIiC;AAErC,MAAMC,SAAS,GAAGP,cAAc,CAACM,QAAD,CAAhC;AAEA,SAAOF,QAAQ,CACb,qBADa,EAEbI,oBAFa,EAGbD,SAAS,GACPA,SAAS,CAAC,YAAD,CADF,CAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATO,IAUPJ,eAAe,EAbJ,CAAR,CAcLG,QAdK,CAAP;AAeD;;AAED,SAASE,oBAAT,CAIEF,QAJF,EAIuC;AAErCR,uBAAqB,CAACQ,QAAD,CAArB;;AACM,WAA0CT,KAAK,CAACY,QAAN,CAAeH,QAAf,CAA1C;AAAA,MAACI,gBAAgB,QAAjB;AAAA,MAAmBC,mBAAmB,QAAtC;;AACA,WAAwCd,KAAK,CAACY,QAAN,CAAeH,QAAf,CAAxC;AAAA,MAACM,eAAe,QAAhB;AAAA,MAAkBC,kBAAkB,QAApC;;AACN,MAAMC,gBAAgB,GAAGd,cAAc,CAACM,QAAD,CAAvC,CALqC,CAOrC;AACA;AACA;;AACA,MAAII,gBAAgB,KAAKJ,QAAzB,EAAmC;AACjCK,uBAAmB,CAACL,QAAD,CAAnB;AACAO,sBAAkB,CAACP,QAAD,CAAlB;AACD,GAHD,MAGO;AACLL,yBAAqB,CAACK,QAAD,EAAWP,iBAAiB,CAACa,eAAD,CAA5B,CAArB;AACD;;AAED,MAAMG,OAAO,GAAuClB,KAAK,CAACmB,WAAN,CAClD,UAACC,SAAD,EAAU;AACR,QAAMC,OAAO,GAAGJ,gBAAgB,CAACC,OAAjB,CAAyBE,SAAzB,CAAhB;AAEAJ,sBAAkB,CAACX,YAAY,CAACY,gBAAD,CAAb,CAAlB;AAEA,WAAOI,OAAP;AACD,GAPiD,EAQlD,CAACJ,gBAAD,CARkD,CAApD;AAWA,MAAMK,SAAS,GAAyCtB,KAAK,CAACmB,WAAN,CACtD,UAACI,OAAD,EAAQ;AACN,QAAMF,OAAO,GAAGJ,gBAAgB,CAACK,SAAjB,CACdC,OADc,CAAhB;AAIAP,sBAAkB,CAACX,YAAY,CAACY,gBAAD,CAAb,CAAlB;AAEA,WAAOI,OAAP;AACD,GATqD,EAUtD,CAACJ,gBAAD,CAVsD,CAAxD;AAaA,SAAO;AACLC,WAAO,SADF;AAELI,aAAS,WAFJ;AAGLE,mBAAe,EAAEP,gBAAgB,CAACQ,UAAjB,CAA4BD;AAHxC,GAAP;AAKD","names":["React","assertWrappedQueryRef","getWrappedPromise","unwrapQueryRef","updateWrappedQueryRef","wrapQueryRef","useApolloClient","wrapHook","useQueryRefHandlers","queryRef","unwrapped","_useQueryRefHandlers","useState","previousQueryRef","setPreviousQueryRef","wrappedQueryRef","setWrappedQueryRef","internalQueryRef","refetch","useCallback","variables","promise","fetchMore","options","subscribeToMore","observable"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/react/hooks/useQueryRefHandlers.ts"],"sourcesContent":["import * as React from \"rehackt\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type { QueryRef } from \"../internal/index.js\";\nimport type { OperationVariables } from \"../../core/types.js\";\nimport type {\n  RefetchFunction,\n  FetchMoreFunction,\n  SubscribeToMoreFunction,\n} from \"./useSuspenseQuery.js\";\nimport type { FetchMoreQueryOptions } from \"../../core/watchQueryOptions.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapHook } from \"./internal/index.js\";\n\nexport interface UseQueryRefHandlersResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  /** {@inheritDoc @apollo/client!ObservableQuery#refetch:member(1)} */\n  refetch: RefetchFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)} */\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n * @since 3.9.0\n * @param queryRef - A `QueryRef` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables>\n): UseQueryRefHandlersResult<TData, TVariables> {\n  const unwrapped = unwrapQueryRef(queryRef);\n\n  return wrapHook(\n    \"useQueryRefHandlers\",\n    _useQueryRefHandlers,\n    unwrapped ?\n      unwrapped[\"observable\"]\n      // in the case of a \"transported\" queryRef object, we need to use the\n      // client that's available to us at the current position in the React tree\n      // that ApolloClient will then have the job to recreate a real queryRef from\n      // the transported object\n      // This is just a context read - it's fine to do this conditionally.\n      // This hook wrapper also shouldn't be optimized by React Compiler.\n      // eslint-disable-next-line react-compiler/react-compiler\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n    : useApolloClient()\n  )(queryRef);\n}\n\nfunction _useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables>\n): UseQueryRefHandlersResult<TData, TVariables> {\n  assertWrappedQueryRef(queryRef);\n  const [previousQueryRef, setPreviousQueryRef] = React.useState(queryRef);\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(queryRef);\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = internalQueryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = internalQueryRef.fetchMore(\n        options as FetchMoreQueryOptions<any, any>\n      );\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  return {\n    refetch,\n    fetchMore,\n    subscribeToMore: internalQueryRef.observable.subscribeToMore,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}