{"ast":null,"code":"import { invariant } from \"../utilities/globals/index.js\";\nimport { createFragmentMap, getFragmentDefinitions, getOperationDefinition } from \"../utilities/index.js\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport { MapImpl, SetImpl, warnOnImproperCacheImplementation } from \"./utils.js\";\n/** @internal */\n\nexport function maskOperation(data, document, cache) {\n  var _a;\n\n  if (!cache.fragmentMatches) {\n    if (globalThis.__DEV__ !== false) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  var definition = getOperationDefinition(document);\n  invariant(definition, 51);\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache: cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl()\n  });\n}","map":{"version":3,"mappings":"AAKA,SAASA,SAAT,QAA0B,+BAA1B;AACA,SACEC,iBADF,EAEEC,sBAFF,EAGEC,sBAHF,QAIO,uBAJP;AAKA,SAASC,cAAT,QAA+B,qBAA/B;AACA,SACEC,OADF,EAEEC,OAFF,EAGEC,iCAHF,QAIO,YAJP;AAMA;;AACA,OAAM,SAAUC,aAAV,CACJC,IADI,EAEJC,QAFI,EAGJC,KAHI,EAGuB;;;AAE3B,MAAI,CAACA,KAAK,CAACC,eAAX,EAA4B;AAC1B,QAAIC,UAAU,QAAV,KAAU,KAAd,EAAc;AACZN,uCAAiC;AAClC;;AAED,WAAOE,IAAP;AACD;;AAED,MAAMK,UAAU,GAAGX,sBAAsB,CAACO,QAAD,CAAzC;AAEAV,WAAS,CACPc,UADO,EAEP,EAFO,CAAT;;AAKA,MAAIL,IAAI,IAAI,IAAZ,EAAkB;AAChB;AACA,WAAOA,IAAP;AACD;;AAED,SAAOL,cAAc,CAACK,IAAD,EAAOK,UAAU,CAACC,YAAlB,EAAgC;AACnDC,iBAAa,EAAEF,UAAU,CAACG,SADyB;AAEnDC,iBAAa,EAAE,gBAAU,CAACC,IAAX,MAAe,IAAf,IAAeC,aAAf,GAAe,MAAf,GAAeA,GAAEC,KAFmB;AAGnDC,eAAW,EAAErB,iBAAiB,CAACC,sBAAsB,CAACQ,QAAD,CAAvB,CAHqB;AAInDC,SAAK,OAJ8C;AAKnDY,kBAAc,EAAE,IAAIlB,OAAJ,EALmC;AAMnDmB,gBAAY,EAAE,IAAIlB,OAAJ;AANqC,GAAhC,CAArB;AAQD","names":["invariant","createFragmentMap","getFragmentDefinitions","getOperationDefinition","maskDefinition","MapImpl","SetImpl","warnOnImproperCacheImplementation","maskOperation","data","document","cache","fragmentMatches","globalThis","definition","selectionSet","operationType","operation","operationName","name","_a","value","fragmentMap","mutableTargets","knownChanged"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/masking/maskOperation.ts"],"sourcesContent":["import type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getOperationDefinition,\n} from \"../utilities/index.js\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\n\n/** @internal */\nexport function maskOperation<TData = unknown>(\n  data: TData,\n  document: DocumentNode | TypedDocumentNode<TData>,\n  cache: ApolloCache<unknown>\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const definition = getOperationDefinition(document);\n\n  invariant(\n    definition,\n    \"Expected a parsed GraphQL document with a query, mutation, or subscription.\"\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: definition.name?.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n"]},"metadata":{},"sourceType":"module"}