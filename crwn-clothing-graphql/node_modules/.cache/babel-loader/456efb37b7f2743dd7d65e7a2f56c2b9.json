{"ast":null,"code":"import { __rest } from \"tslib\";\nimport equal from \"@wry/equality\";\nimport { createFragmentMap, getFragmentDefinitions, getFragmentFromSelection, getMainDefinition, isField, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\"; // Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\n\nexport function equalByQuery(query, _a, _b, variables) {\n  var aData = _a.data,\n      aRest = __rest(_a, [\"data\"]);\n\n  var bData = _b.data,\n      bRest = __rest(_b, [\"data\"]);\n\n  return equal(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n    variables: variables\n  });\n}\n\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n  if (aResult === bResult) {\n    return true;\n  }\n\n  var seenSelections = new Set(); // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n\n  return selectionSet.selections.every(function (selection) {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection); // Ignore @skip(if: true) and @include(if: false) fields.\n\n    if (!shouldInclude(selection, context.variables)) return true; // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n\n    if (selectionHasNonreactiveDirective(selection)) return true;\n\n    if (isField(selection)) {\n      var resultKey = resultKeyNameFromField(selection);\n      var aResultChild = aResult && aResult[resultKey];\n      var bResultChild = bResult && bResult[resultKey];\n      var childSelectionSet = selection.selectionSet;\n\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n\n      var aChildIsArray = Array.isArray(aResultChild);\n      var bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n\n      if (aChildIsArray && bChildIsArray) {\n        var length_1 = aResultChild.length;\n\n        if (bResultChild.length !== length_1) {\n          return false;\n        }\n\n        for (var i = 0; i < length_1; ++i) {\n          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n    } else {\n      var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n        return equalBySelectionSet(fragment.selectionSet, // Notice that we reuse the same aResult and bResult values here,\n        // since the fragment ...spread does not specify a field name, but\n        // consists of multiple fields (within the fragment's selection set)\n        // that should be applied to the current result value(s).\n        aResult, bResult, context);\n      }\n    }\n  });\n}\n\nfunction selectionHasNonreactiveDirective(selection) {\n  return !!selection.directives && selection.directives.some(directiveIsNonreactive);\n}\n\nfunction directiveIsNonreactive(dir) {\n  return dir.name.value === \"nonreactive\";\n}","map":{"version":3,"mappings":"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","names":["equal","createFragmentMap","getFragmentDefinitions","getFragmentFromSelection","getMainDefinition","isField","resultKeyNameFromField","shouldInclude","equalByQuery","query","_a","_b","variables","aData","aRest","bData","bRest","equalBySelectionSet","selectionSet","fragmentMap","aResult","bResult","context","seenSelections","Set","selections","every","selection","has","add","selectionHasNonreactiveDirective","resultKey","aResultChild","bResultChild","childSelectionSet","aChildIsArray","Array","isArray","bChildIsArray","length_1","length","i","fragment","directives","some","directiveIsNonreactive","dir","name","value"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/core/equalByQuery.ts"],"sourcesContent":["import equal from \"@wry/equality\";\n\nimport type {\n  DirectiveNode,\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  SelectionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { ApolloQueryResult, OperationVariables } from \"./types.js\";\n\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getFragmentFromSelection,\n  getMainDefinition,\n  isField,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\n\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(\n  query: DocumentNode,\n  { data: aData, ...aRest }: Partial<ApolloQueryResult<unknown>>,\n  { data: bData, ...bRest }: Partial<ApolloQueryResult<unknown>>,\n  variables?: OperationVariables\n): boolean {\n  return (\n    equal(aRest, bRest) &&\n    equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      variables,\n    })\n  );\n}\n\n// Encapsulates the information used by equalBySelectionSet that does not change\n// during the recursion.\ninterface CompareContext<TVariables> {\n  fragmentMap: FragmentMap;\n  variables: TVariables | undefined;\n}\n\nfunction equalBySelectionSet(\n  selectionSet: SelectionSetNode,\n  aResult: any,\n  bResult: any,\n  context: CompareContext<OperationVariables>\n): boolean {\n  if (aResult === bResult) {\n    return true;\n  }\n\n  const seenSelections = new Set<SelectionNode>();\n\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every((selection) => {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n\n    if (isField(selection)) {\n      const resultKey = resultKeyNameFromField(selection);\n      const aResultChild = aResult && aResult[resultKey];\n      const bResultChild = bResult && bResult[resultKey];\n      const childSelectionSet = selection.selectionSet;\n\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n\n      const aChildIsArray = Array.isArray(aResultChild);\n      const bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        const length = aResultChild.length;\n        if (bResultChild.length !== length) {\n          return false;\n        }\n        for (let i = 0; i < length; ++i) {\n          if (\n            !equalBySelectionSet(\n              childSelectionSet,\n              aResultChild[i],\n              bResultChild[i],\n              context\n            )\n          ) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      return equalBySelectionSet(\n        childSelectionSet,\n        aResultChild,\n        bResultChild,\n        context\n      );\n    } else {\n      const fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n\n        return equalBySelectionSet(\n          fragment.selectionSet,\n          // Notice that we reuse the same aResult and bResult values here,\n          // since the fragment ...spread does not specify a field name, but\n          // consists of multiple fields (within the fragment's selection set)\n          // that should be applied to the current result value(s).\n          aResult,\n          bResult,\n          context\n        );\n      }\n    }\n  });\n}\n\nfunction selectionHasNonreactiveDirective(\n  selection:\n    | FieldNode\n    | InlineFragmentNode\n    | FragmentSpreadNode\n    | FragmentDefinitionNode\n): boolean {\n  return (\n    !!selection.directives && selection.directives.some(directiveIsNonreactive)\n  );\n}\n\nfunction directiveIsNonreactive(dir: DirectiveNode): boolean {\n  return dir.name.value === \"nonreactive\";\n}\n"]},"metadata":{},"sourceType":"module"}