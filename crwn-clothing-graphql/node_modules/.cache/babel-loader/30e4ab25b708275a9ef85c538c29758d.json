{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nvar LocalState =\n/** @class */\nfunction () {\n  function LocalState(_a) {\n    var cache = _a.cache,\n        client = _a.client,\n        resolvers = _a.resolvers,\n        fragmentMatcher = _a.fragmentMatcher;\n    this.selectionsToResolveCache = new WeakMap();\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  LocalState.prototype.addResolvers = function (resolvers) {\n    var _this = this;\n\n    this.resolvers = this.resolvers || {};\n\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(function (resolverGroup) {\n        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  };\n\n  LocalState.prototype.setResolvers = function (resolvers) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  };\n\n  LocalState.prototype.getResolvers = function () {\n    return this.resolvers || {};\n  }; // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n\n\n  LocalState.prototype.runResolvers = function (_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n      var document = _b.document,\n          remoteResult = _b.remoteResult,\n          context = _b.context,\n          variables = _b.variables,\n          _c = _b.onlyRunForcedResolvers,\n          onlyRunForcedResolvers = _c === void 0 ? false : _c;\n      return __generator(this, function (_d) {\n        if (document) {\n          return [2\n          /*return*/\n          , this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {\n            return __assign(__assign({}, remoteResult), {\n              data: localResult.result\n            });\n          })];\n        }\n\n        return [2\n        /*return*/\n        , remoteResult];\n      });\n    });\n  };\n\n  LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  };\n\n  LocalState.prototype.getFragmentMatcher = function () {\n    return this.fragmentMatcher;\n  }; // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n\n\n  LocalState.prototype.clientQuery = function (document) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n\n    return null;\n  }; // Server queries are stripped of all @client based selection sets.\n\n\n  LocalState.prototype.serverQuery = function (document) {\n    return removeClientSetsFromDocument(document);\n  };\n\n  LocalState.prototype.prepareContext = function (context) {\n    var cache = this.cache;\n    return __assign(__assign({}, context), {\n      cache: cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: function (obj) {\n        return cache.identify(obj);\n      }\n    });\n  }; // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n\n\n  LocalState.prototype.addExportedVariables = function (document_1) {\n    return __awaiter(this, arguments, void 0, function (document, variables, context) {\n      if (variables === void 0) {\n        variables = {};\n      }\n\n      if (context === void 0) {\n        context = {};\n      }\n\n      return __generator(this, function (_a) {\n        if (document) {\n          return [2\n          /*return*/\n          , this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {\n            return __assign(__assign({}, variables), data.exportedVariables);\n          })];\n        }\n\n        return [2\n        /*return*/\n        , __assign({}, variables)];\n      });\n    });\n  };\n\n  LocalState.prototype.shouldForceResolvers = function (document) {\n    var forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter: function (node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(function (arg) {\n              return arg.name.value === \"always\" && arg.value.kind === \"BooleanValue\" && arg.value.value === true;\n            });\n\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        }\n      }\n    });\n    return forceResolvers;\n  }; // Query the cache and return matching data.\n\n\n  LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables: variables,\n      returnPartialData: true,\n      optimistic: false\n    }).result;\n  };\n\n  LocalState.prototype.resolveDocument = function (document_1, rootValue_1) {\n    return __awaiter(this, arguments, void 0, function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n      var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n\n      if (context === void 0) {\n        context = {};\n      }\n\n      if (variables === void 0) {\n        variables = {};\n      }\n\n      if (fragmentMatcher === void 0) {\n        fragmentMatcher = function () {\n          return true;\n        };\n      }\n\n      if (onlyRunForcedResolvers === void 0) {\n        onlyRunForcedResolvers = false;\n      }\n\n      return __generator(this, function (_b) {\n        mainDefinition = getMainDefinition(document);\n        fragments = getFragmentDefinitions(document);\n        fragmentMap = createFragmentMap(fragments);\n        selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n        definitionOperation = mainDefinition.operation;\n        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : \"Query\";\n        _a = this, cache = _a.cache, client = _a.client;\n        execContext = {\n          fragmentMap: fragmentMap,\n          context: __assign(__assign({}, context), {\n            cache: cache,\n            client: client\n          }),\n          variables: variables,\n          fragmentMatcher: fragmentMatcher,\n          defaultOperationType: defaultOperationType,\n          exportedVariables: {},\n          selectionsToResolve: selectionsToResolve,\n          onlyRunForcedResolvers: onlyRunForcedResolvers\n        };\n        isClientFieldDescendant = false;\n        return [2\n        /*return*/\n        , this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (result) {\n          return {\n            result: result,\n            exportedVariables: execContext.exportedVariables\n          };\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveSelectionSet = function (selectionSet, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fragmentMap, context, variables, resultsToMerge, execute;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n        resultsToMerge = [rootValue];\n\n        execute = function (selection) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var fragment, typeCondition;\n            return __generator(this, function (_a) {\n              if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {\n                // Skip selections without @client directives\n                // (still processing if one of the ancestors or one of the child fields has @client directive)\n                return [2\n                /*return*/\n                ];\n              }\n\n              if (!shouldInclude(selection, variables)) {\n                // Skip this entirely.\n                return [2\n                /*return*/\n                ];\n              }\n\n              if (isField(selection)) {\n                return [2\n                /*return*/\n                , this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function (fieldResult) {\n                  var _a;\n\n                  if (typeof fieldResult !== \"undefined\") {\n                    resultsToMerge.push((_a = {}, _a[resultKeyNameFromField(selection)] = fieldResult, _a));\n                  }\n                })];\n              }\n\n              if (isInlineFragment(selection)) {\n                fragment = selection;\n              } else {\n                // This is a named fragment.\n                fragment = fragmentMap[selection.name.value];\n                invariant(fragment, 19, selection.name.value);\n              }\n\n              if (fragment && fragment.typeCondition) {\n                typeCondition = fragment.typeCondition.name.value;\n\n                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                  return [2\n                  /*return*/\n                  , this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (fragmentResult) {\n                    resultsToMerge.push(fragmentResult);\n                  })];\n                }\n              }\n\n              return [2\n              /*return*/\n              ];\n            });\n          });\n        };\n\n        return [2\n        /*return*/\n        , Promise.all(selectionSet.selections.map(execute)).then(function () {\n          return mergeDeepArray(resultsToMerge);\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveField = function (field, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        if (!rootValue) {\n          return [2\n          /*return*/\n          , null];\n        }\n\n        variables = execContext.variables;\n        fieldName = field.name.value;\n        aliasedFieldName = resultKeyNameFromField(field);\n        aliasUsed = fieldName !== aliasedFieldName;\n        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n        resultPromise = Promise.resolve(defaultResult); // Usually all local resolvers are run when passing through here, but\n        // if we've specifically identified that we only want to run forced\n        // resolvers (that is, resolvers for fields marked with\n        // `@client(always: true)`), then we'll skip running non-forced resolvers.\n\n        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n          resolverType = rootValue.__typename || execContext.defaultOperationType;\n          resolverMap = this.resolvers && this.resolvers[resolverType];\n\n          if (resolverMap) {\n            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n\n            if (resolve) {\n              resultPromise = Promise.resolve( // In case the resolve function accesses reactive variables,\n              // set cacheSlot to the current cache instance.\n              cacheSlot.withValue(this.cache, resolve, [rootValue, argumentsObjectFromField(field, variables), execContext.context, {\n                field: field,\n                fragmentMap: execContext.fragmentMap\n              }]));\n            }\n          }\n        }\n\n        return [2\n        /*return*/\n        , resultPromise.then(function (result) {\n          var _a, _b;\n\n          if (result === void 0) {\n            result = defaultResult;\n          } // If an @export directive is associated with the current field, store\n          // the `as` export variable name and current result for later use.\n\n\n          if (field.directives) {\n            field.directives.forEach(function (directive) {\n              if (directive.name.value === \"export\" && directive.arguments) {\n                directive.arguments.forEach(function (arg) {\n                  if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                    execContext.exportedVariables[arg.value.value] = result;\n                  }\n                });\n              }\n            });\n          } // Handle all scalar types here.\n\n\n          if (!field.selectionSet) {\n            return result;\n          } // From here down, the field has a selection set, which means it's trying\n          // to query a GraphQLObjectType.\n\n\n          if (result == null) {\n            // Basically any field in a GraphQL response can be null, or missing\n            return result;\n          }\n\n          var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function (d) {\n            return d.name.value === \"client\";\n          })) !== null && _b !== void 0 ? _b : false;\n\n          if (Array.isArray(result)) {\n            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n          } // Returned value is an object, and the query has a sub-selection. Recurse.\n\n\n          if (field.selectionSet) {\n            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n          }\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveSubSelectedArray = function (field, isClientFieldDescendant, result, execContext) {\n    var _this = this;\n\n    return Promise.all(result.map(function (item) {\n      if (item === null) {\n        return null;\n      } // This is a nested array, recurse.\n\n\n      if (Array.isArray(item)) {\n        return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n      } // This is an object, run the selection set on it.\n\n\n      if (field.selectionSet) {\n        return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n      }\n    }));\n  }; // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n\n\n  LocalState.prototype.collectSelectionsToResolve = function (mainDefinition, fragmentMap) {\n    var isSingleASTNode = function (node) {\n      return !Array.isArray(node);\n    };\n\n    var selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(definitionNode) {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        var matches_1 = new Set();\n        selectionsToResolveCache.set(definitionNode, matches_1);\n        visit(definitionNode, {\n          Directive: function (node, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread: function (spread, _, __, ___, ancestors) {\n            var fragment = fragmentMap[spread.name.value];\n            invariant(fragment, 20, spread.name.value);\n            var fragmentSelections = collectByDefinition(fragment);\n\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n              matches_1.add(spread);\n              fragmentSelections.forEach(function (selection) {\n                matches_1.add(selection);\n              });\n            }\n          }\n        });\n      }\n\n      return selectionsToResolveCache.get(definitionNode);\n    }\n\n    return collectByDefinition(mainDefinition);\n  };\n\n  return LocalState;\n}();\n\nexport { LocalState };","map":{"version":3,"mappings":"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","names":["invariant","visit","BREAK","isSelectionNode","argumentsObjectFromField","buildQueryFromSelectionSet","createFragmentMap","getFragmentDefinitions","getMainDefinition","hasDirectives","isField","isInlineFragment","mergeDeep","mergeDeepArray","removeClientSetsFromDocument","resultKeyNameFromField","shouldInclude","cacheSlot","_a","cache","client","resolvers","fragmentMatcher","WeakMap","addResolvers","setFragmentMatcher","LocalState","Array","isArray","forEach","resolverGroup","_this","_b","document","remoteResult","context","variables","_c","onlyRunForcedResolvers","resolveDocument","data","then","localResult","result","getCacheKey","obj","identify","buildRootValueFromCache","prepareContext","exportedVariables","forceResolvers","Directive","enter","node","name","value","arguments","some","arg","kind","diff","query","returnPartialData","optimistic","rootValue","mainDefinition","fragments","fragmentMap","selectionsToResolve","collectSelectionsToResolve","definitionOperation","operation","defaultOperationType","charAt","toUpperCase","slice","execContext","isClientFieldDescendant","resolveSelectionSet","selectionSet","resultsToMerge","execute","selection","has","resolveField","fieldResult","push","fragment","typeCondition","fragmentResult","Promise","all","selections","map","field","fieldName","aliasedFieldName","aliasUsed","defaultResult","resultPromise","resolve","shouldForceResolvers","resolverType","__typename","resolverMap","withValue","directives","directive","isClientField","d","resolveSubSelectedArray","item","isSingleASTNode","selectionsToResolveCache","collectByDefinition","definitionNode","matches_1","Set","set","_","__","___","ancestors","add","FragmentSpread","spread","fragmentSelections","size","get"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/core/LocalState.ts"],"sourcesContent":["import { invariant } from \"../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  DirectiveNode,\n  FragmentSpreadNode,\n  ExecutableDefinitionNode,\n} from \"graphql\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\n\nimport type { ApolloCache } from \"../cache/index.js\";\nimport type { FragmentMap, StoreObject } from \"../utilities/index.js\";\nimport {\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { Resolvers, OperationVariables } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  }\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n  selectionsToResolve: Set<SelectionNode>;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client?: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher?: FragmentMatcher;\n  private selectionsToResolveCache = new WeakMap<\n    ExecutableDefinitionNode,\n    Set<SelectionNode>\n  >();\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach((resolverGroup) => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers\n      ).then((localResult) => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher | undefined {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables<TVars extends OperationVariables>(\n    document: DocumentNode,\n    variables: TVars = {} as TVars,\n    context = {}\n  ): /* returns at least the variables that were passed in */ Promise<TVars> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables\n      ).then((data) => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(\n              (arg) =>\n                arg.name.value === \"always\" &&\n                arg.value.kind === \"BooleanValue\" &&\n                arg.value.value === true\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false\n  ) {\n    const mainDefinition = getMainDefinition(\n      document\n    ) as OperationDefinitionNode;\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n    const selectionsToResolve = this.collectSelectionsToResolve(\n      mainDefinition,\n      fragmentMap\n    );\n\n    const definitionOperation = mainDefinition.operation;\n\n    const defaultOperationType =\n      definitionOperation ?\n        definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : \"Query\";\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      selectionsToResolve,\n      onlyRunForcedResolvers,\n    };\n    const isClientFieldDescendant = false;\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      isClientFieldDescendant,\n      rootValue,\n      execContext\n    ).then((result) => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    isClientFieldDescendant: boolean,\n    rootValue: TData,\n    execContext: ExecContext\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (\n        !isClientFieldDescendant &&\n        !execContext.selectionsToResolve.has(selection)\n      ) {\n        // Skip selections without @client directives\n        // (still processing if one of the ancestors or one of the child fields has @client directive)\n        return;\n      }\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(\n          selection,\n          isClientFieldDescendant,\n          rootValue,\n          execContext\n        ).then((fieldResult) => {\n          if (typeof fieldResult !== \"undefined\") {\n            resultsToMerge.push({\n              [resultKeyNameFromField(selection)]: fieldResult,\n            } as TData);\n          }\n        });\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named %s`, selection.name.value);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            isClientFieldDescendant,\n            rootValue,\n            execContext\n          ).then((fragmentResult) => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function () {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    rootValue: any,\n    execContext: ExecContext\n  ): Promise<any> {\n    if (!rootValue) {\n      return null;\n    }\n\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach((directive) => {\n          if (directive.name.value === \"export\" && directive.arguments) {\n            directive.arguments.forEach((arg) => {\n              if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      const isClientField =\n        field.directives?.some((d) => d.name.value === \"client\") ?? false;\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(\n          field,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    result: any[],\n    execContext: ExecContext\n  ): any {\n    return Promise.all(\n      result.map((item) => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(\n            field,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(\n            field.selectionSet,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n      })\n    );\n  }\n\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  private collectSelectionsToResolve(\n    mainDefinition: OperationDefinitionNode,\n    fragmentMap: FragmentMap\n  ): Set<SelectionNode> {\n    const isSingleASTNode = (\n      node: ASTNode | readonly ASTNode[]\n    ): node is ASTNode => !Array.isArray(node);\n    const selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(\n      definitionNode: ExecutableDefinitionNode\n    ): Set<SelectionNode> {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        const matches = new Set<SelectionNode>();\n        selectionsToResolveCache.set(definitionNode, matches);\n\n        visit(definitionNode, {\n          Directive(node: DirectiveNode, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread(spread: FragmentSpreadNode, _, __, ___, ancestors) {\n            const fragment = fragmentMap[spread.name.value];\n            invariant(fragment, `No fragment named %s`, spread.name.value);\n\n            const fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n              matches.add(spread);\n              fragmentSelections.forEach((selection) => {\n                matches.add(selection);\n              });\n            }\n          },\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode)!;\n    }\n    return collectByDefinition(mainDefinition);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}