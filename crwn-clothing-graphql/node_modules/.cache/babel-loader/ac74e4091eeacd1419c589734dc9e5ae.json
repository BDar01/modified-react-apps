{"ast":null,"code":"// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext = null; // This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\n\nconst MISSING_VALUE = {};\nlet idCounter = 1; // Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\n\nconst makeSlotClass = () => class Slot {\n  constructor() {\n    // If you have a Slot object, you can find out its slot.id, but you cannot\n    // guess the slot.id of a Slot you don't have access to, thanks to the\n    // randomized suffix.\n    this.id = [\"slot\", idCounter++, Date.now(), Math.random().toString(36).slice(2)].join(\":\");\n  }\n\n  hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext.slots[this.id] = value;\n        }\n\n        return true;\n      }\n    }\n\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n\n    return false;\n  }\n\n  getValue() {\n    if (this.hasValue()) {\n      return currentContext.slots[this.id];\n    }\n  }\n\n  withValue(value, callback, // Given the prevalence of arrow functions, specifying arguments is likely\n  // to be much more common than specifying `this`, hence this ordering:\n  args, thisArg) {\n    const slots = {\n      __proto__: null,\n      [this.id]: value\n    };\n    const parent = currentContext;\n    currentContext = {\n      parent,\n      slots\n    };\n\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg, args);\n    } finally {\n      currentContext = parent;\n    }\n  } // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n\n\n  static bind(callback) {\n    const context = currentContext;\n    return function () {\n      const saved = currentContext;\n\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments);\n      } finally {\n        currentContext = saved;\n      }\n    };\n  } // Immediately run a callback function without any captured context.\n\n\n  static noContext(callback, // Given the prevalence of arrow functions, specifying arguments is likely\n  // to be much more common than specifying `this`, hence this ordering:\n  args, thisArg) {\n    if (currentContext) {\n      const saved = currentContext;\n\n      try {\n        currentContext = null; // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n\n        return callback.apply(thisArg, args);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg, args);\n    }\n  }\n\n};\n\nfunction maybe(fn) {\n  try {\n    return fn();\n  } catch (ignored) {}\n} // We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\n\n\nconst globalKey = \"@wry/context:Slot\";\nconst host = // Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some\n// bundlers to the appropriate identifier (window, self, ...) depending on the\n// bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\nmaybe(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall\n// back to using the Array constructor as a namespace, but that was flagged in\n// https://github.com/benjamn/wryware/issues/347, and can be avoided.\nObject.create(null); // Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\n\nconst globalHost = host;\nexport const Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array\n// constructor, so we check there as well, to prevent Slot class duplication.\nArray[globalKey] || function (Slot) {\n  try {\n    Object.defineProperty(globalHost, globalKey, {\n      value: Slot,\n      enumerable: false,\n      writable: false,\n      // When it was possible for globalHost to be the Array constructor (a\n      // legacy Slot dedup strategy), it was important for the property to be\n      // configurable:true so it could be deleted. That does not seem to be as\n      // important when globalHost is the global object, but I don't want to\n      // cause similar problems again, and configurable:true seems safest.\n      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n      configurable: true\n    });\n  } finally {\n    return Slot;\n  }\n}(makeSlotClass());","map":{"version":3,"mappings":"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","names":["currentContext","MISSING_VALUE","idCounter","makeSlotClass","Slot","constructor","Date","now","Math","random","toString","slice","join","hasValue","context","parent","id","slots","value","getValue","withValue","callback","args","thisArg","__proto__","apply","bind","saved","arguments","noContext","maybe","fn","ignored","globalKey","host","globalThis","global","Object","create","globalHost","Array","defineProperty","enumerable","writable","configurable"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@wry/context/src/slot.ts"],"sourcesContent":["type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult, TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: TThis) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\nfunction maybe<T>(fn: () => T): T | undefined {\n  try {\n    return fn();\n  } catch (ignored) {}\n}\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\n\nconst host =\n  // Prefer globalThis when available.\n  // https://github.com/benjamn/wryware/issues/347\n  maybe(() => globalThis) ||\n  // Fall back to global, which works in Node.js and may be converted by some\n  // bundlers to the appropriate identifier (window, self, ...) depending on the\n  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n  maybe(() => global) ||\n  // Otherwise, use a dummy host that's local to this module. We used to fall\n  // back to using the Array constructor as a namespace, but that was flagged in\n  // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n  Object.create(null) as typeof Array;\n\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nconst globalHost: typeof host & {\n  [globalKey]?: typeof Slot;\n} = host;\n\nexport const Slot: ReturnType<typeof makeSlotClass> =\n  globalHost[globalKey] ||\n  // Earlier versions of this package stored the globalKey property on the Array\n  // constructor, so we check there as well, to prevent Slot class duplication.\n  (Array as typeof globalHost)[globalKey] ||\n  (function (Slot) {\n    try {\n      Object.defineProperty(globalHost, globalKey, {\n        value: Slot,\n        enumerable: false,\n        writable: false,\n        // When it was possible for globalHost to be the Array constructor (a\n        // legacy Slot dedup strategy), it was important for the property to be\n        // configurable:true so it could be deleted. That does not seem to be as\n        // important when globalHost is the global object, but I don't want to\n        // cause similar problems again, and configurable:true seems safest.\n        // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n        configurable: true\n      });\n    } finally {\n      return Slot;\n    }\n  })(makeSlotClass());\n"]},"metadata":{},"sourceType":"module"}