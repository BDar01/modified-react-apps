{"ast":null,"code":"import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nconst MAX_LISTS_DEPTH = 3;\nexport function MaxIntrospectionDepthRule(context) {\n  /**\n   * Counts the depth of list fields in \"__Type\" recursively and\n   * returns `true` if the limit has been reached.\n   */\n  function checkDepth(node) {\n    let visitedFragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.create(null);\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = node.name.value;\n\n      if (visitedFragments[fragmentName] === true) {\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\n        return false;\n      }\n\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\n        return false;\n      } // Rather than following an immutable programming pattern which has\n      // significant memory and garbage collection overhead, we've opted to\n      // take a mutable approach for efficiency's sake. Importantly visiting a\n      // fragment twice is fine, so long as you don't do one visit inside the\n      // other.\n\n\n      try {\n        visitedFragments[fragmentName] = true;\n        return checkDepth(fragment, visitedFragments, depth);\n      } finally {\n        visitedFragments[fragmentName] = undefined;\n      }\n    }\n\n    if (node.kind === Kind.FIELD && ( // check all introspection lists\n    node.name.value === 'fields' || node.name.value === 'interfaces' || node.name.value === 'possibleTypes' || node.name.value === 'inputFields')) {\n      // eslint-disable-next-line no-param-reassign\n      depth++;\n\n      if (depth >= MAX_LISTS_DEPTH) {\n        return true;\n      }\n    } // handles fields and inline fragments\n\n\n    if ('selectionSet' in node && node.selectionSet) {\n      for (const child of node.selectionSet.selections) {\n        if (checkDepth(child, visitedFragments, depth)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    Field(node) {\n      if (node.name.value === '__schema' || node.name.value === '__type') {\n        if (checkDepth(node)) {\n          context.reportError(new GraphQLError('Maximum introspection depth exceeded', {\n            nodes: [node]\n          }));\n          return false;\n        }\n      }\n    }\n\n  };\n}","map":{"version":3,"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs"],"names":["GraphQLError","Kind","MAX_LISTS_DEPTH","MaxIntrospectionDepthRule","context","checkDepth","node","visitedFragments","Object","create","depth","kind","FRAGMENT_SPREAD","fragmentName","name","value","fragment","getFragment","undefined","FIELD","selectionSet","child","selections","Field","reportError","nodes"],"mappings":"AAAA,SAASA,YAAT,QAA6B,8BAA7B;AACA,SAASC,IAAT,QAAqB,0BAArB;AACA,MAAMC,eAAe,GAAG,CAAxB;AACA,OAAO,SAASC,yBAAT,CAAmCC,OAAnC,EAA4C;AACjD;AACF;AACA;AACA;AACE,WAASC,UAAT,CAAoBC,IAApB,EAA6E;AAAA,QAAnDC,gBAAmD,uEAAhCC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAgC;AAAA,QAAXC,KAAW,uEAAH,CAAG;;AAC3E,QAAIJ,IAAI,CAACK,IAAL,KAAcV,IAAI,CAACW,eAAvB,EAAwC;AACtC,YAAMC,YAAY,GAAGP,IAAI,CAACQ,IAAL,CAAUC,KAA/B;;AAEA,UAAIR,gBAAgB,CAACM,YAAD,CAAhB,KAAmC,IAAvC,EAA6C;AAC3C;AACA,eAAO,KAAP;AACD;;AAED,YAAMG,QAAQ,GAAGZ,OAAO,CAACa,WAAR,CAAoBJ,YAApB,CAAjB;;AAEA,UAAI,CAACG,QAAL,EAAe;AACb;AACA,eAAO,KAAP;AACD,OAbqC,CAapC;AACF;AACA;AACA;AACA;;;AAEA,UAAI;AACFT,QAAAA,gBAAgB,CAACM,YAAD,CAAhB,GAAiC,IAAjC;AACA,eAAOR,UAAU,CAACW,QAAD,EAAWT,gBAAX,EAA6BG,KAA7B,CAAjB;AACD,OAHD,SAGU;AACRH,QAAAA,gBAAgB,CAACM,YAAD,CAAhB,GAAiCK,SAAjC;AACD;AACF;;AAED,QACEZ,IAAI,CAACK,IAAL,KAAcV,IAAI,CAACkB,KAAnB,MAA4B;AAC3Bb,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,QAApB,IACCT,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,YADrB,IAECT,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,eAFrB,IAGCT,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,aAJtB,CADF,EAME;AACA;AACAL,MAAAA,KAAK;;AAEL,UAAIA,KAAK,IAAIR,eAAb,EAA8B;AAC5B,eAAO,IAAP;AACD;AACF,KAzC0E,CAyCzE;;;AAEF,QAAI,kBAAkBI,IAAlB,IAA0BA,IAAI,CAACc,YAAnC,EAAiD;AAC/C,WAAK,MAAMC,KAAX,IAAoBf,IAAI,CAACc,YAAL,CAAkBE,UAAtC,EAAkD;AAChD,YAAIjB,UAAU,CAACgB,KAAD,EAAQd,gBAAR,EAA0BG,KAA1B,CAAd,EAAgD;AAC9C,iBAAO,IAAP;AACD;AACF;AACF;;AAED,WAAO,KAAP;AACD;;AAED,SAAO;AACLa,IAAAA,KAAK,CAACjB,IAAD,EAAO;AACV,UAAIA,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,UAApB,IAAkCT,IAAI,CAACQ,IAAL,CAAUC,KAAV,KAAoB,QAA1D,EAAoE;AAClE,YAAIV,UAAU,CAACC,IAAD,CAAd,EAAsB;AACpBF,UAAAA,OAAO,CAACoB,WAAR,CACE,IAAIxB,YAAJ,CAAiB,sCAAjB,EAAyD;AACvDyB,YAAAA,KAAK,EAAE,CAACnB,IAAD;AADgD,WAAzD,CADF;AAKA,iBAAO,KAAP;AACD;AACF;AACF;;AAZI,GAAP;AAcD","sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nconst MAX_LISTS_DEPTH = 3;\nexport function MaxIntrospectionDepthRule(context) {\n  /**\n   * Counts the depth of list fields in \"__Type\" recursively and\n   * returns `true` if the limit has been reached.\n   */\n  function checkDepth(node, visitedFragments = Object.create(null), depth = 0) {\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = node.name.value;\n\n      if (visitedFragments[fragmentName] === true) {\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\n        return false;\n      }\n\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\n        return false;\n      } // Rather than following an immutable programming pattern which has\n      // significant memory and garbage collection overhead, we've opted to\n      // take a mutable approach for efficiency's sake. Importantly visiting a\n      // fragment twice is fine, so long as you don't do one visit inside the\n      // other.\n\n      try {\n        visitedFragments[fragmentName] = true;\n        return checkDepth(fragment, visitedFragments, depth);\n      } finally {\n        visitedFragments[fragmentName] = undefined;\n      }\n    }\n\n    if (\n      node.kind === Kind.FIELD && // check all introspection lists\n      (node.name.value === 'fields' ||\n        node.name.value === 'interfaces' ||\n        node.name.value === 'possibleTypes' ||\n        node.name.value === 'inputFields')\n    ) {\n      // eslint-disable-next-line no-param-reassign\n      depth++;\n\n      if (depth >= MAX_LISTS_DEPTH) {\n        return true;\n      }\n    } // handles fields and inline fragments\n\n    if ('selectionSet' in node && node.selectionSet) {\n      for (const child of node.selectionSet.selections) {\n        if (checkDepth(child, visitedFragments, depth)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    Field(node) {\n      if (node.name.value === '__schema' || node.name.value === '__type') {\n        if (checkDepth(node)) {\n          context.reportError(\n            new GraphQLError('Maximum introspection depth exceeded', {\n              nodes: [node],\n            }),\n          );\n          return false;\n        }\n      }\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}