{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit, Kind } from \"graphql\";\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition } from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\nvar TYPENAME_FIELD = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: \"__typename\"\n  }\n};\n\nfunction isEmpty(op, fragmentMap) {\n  return !op || op.selectionSet.selections.every(function (selection) {\n    return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);\n  });\n}\n\nfunction nullIfDocIsEmpty(doc) {\n  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;\n}\n\nfunction getDirectiveMatcher(configs) {\n  var names = new Map();\n  var tests = new Map();\n  configs.forEach(function (directive) {\n    if (directive) {\n      if (directive.name) {\n        names.set(directive.name, directive);\n      } else if (directive.test) {\n        tests.set(directive.test, directive);\n      }\n    }\n  });\n  return function (directive) {\n    var config = names.get(directive.name.value);\n\n    if (!config && tests.size) {\n      tests.forEach(function (testConfig, test) {\n        if (test(directive)) {\n          config = testConfig;\n        }\n      });\n    }\n\n    return config;\n  };\n}\n\nfunction makeInUseGetterFunction(defaultKey) {\n  var map = new Map();\n  return function inUseGetterFunction(key) {\n    if (key === void 0) {\n      key = defaultKey;\n    }\n\n    var inUse = map.get(key);\n\n    if (!inUse) {\n      map.set(key, inUse = {\n        // Variable and fragment spread names used directly within this\n        // operation or fragment definition, as identified by key. These sets\n        // will be populated during the first traversal of the document in\n        // removeDirectivesFromDocument below.\n        variables: new Set(),\n        fragmentSpreads: new Set()\n      });\n    }\n\n    return inUse;\n  };\n}\n\nexport function removeDirectivesFromDocument(directives, doc) {\n  checkDocument(doc); // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n  // operations as if their names were \"\". Anonymous fragment definitions are\n  // not supposed to be possible, but the same default naming strategy seems\n  // appropriate for that case as well.\n\n  var getInUseByOperationName = makeInUseGetterFunction(\"\");\n  var getInUseByFragmentName = makeInUseGetterFunction(\"\");\n\n  var getInUse = function (ancestors) {\n    for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\n      if (isArray(ancestor)) continue;\n\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        // If an operation is anonymous, we use the empty string as its key.\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n\n    globalThis.__DEV__ !== false && invariant.error(97);\n    return null;\n  };\n\n  var operationCount = 0;\n\n  for (var i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n\n  var directiveMatcher = getDirectiveMatcher(directives);\n\n  var shouldRemoveField = function (nodeDirectives) {\n    return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function (config) {\n      return config && config.remove;\n    });\n  };\n\n  var originalFragmentDefsByPath = new Map(); // Any time the first traversal of the document below makes a change like\n  // removing a fragment (by returning null), this variable should be set to\n  // true. Once it becomes true, it should never be set to false again. If this\n  // variable remains false throughout the traversal, then we can return the\n  // original doc immediately without any modifications.\n\n  var firstVisitMadeChanges = false;\n  var fieldOrInlineFragmentVisitor = {\n    enter: function (node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    }\n  };\n  var docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n    VariableDefinition: {\n      enter: function () {\n        // VariableDefinition nodes do not count as variables in use, though\n        // they do contain Variable nodes that might be visited below. To avoid\n        // counting variable declarations as usages, we skip visiting the\n        // contents of this VariableDefinition node by returning false.\n        return false;\n      }\n    },\n    Variable: {\n      enter: function (node, _key, _parent, _path, ancestors) {\n        var inUse = getInUse(ancestors);\n\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      }\n    },\n    FragmentSpread: {\n      enter: function (node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n\n        var inUse = getInUse(ancestors);\n\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        } // We might like to remove this FragmentSpread by returning null here if\n        // the corresponding FragmentDefinition node is also going to be removed\n        // by the logic below, but we can't control the relative order of those\n        // events, so we have to postpone the removal of dangling FragmentSpread\n        // nodes until after the current visit of the document has finished.\n\n      }\n    },\n    FragmentDefinition: {\n      enter: function (node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave: function (node, _key, _parent, path) {\n        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n\n        if (node === originalNode) {\n          // If the FragmentNode received by this leave function is identical to\n          // the one received by the corresponding enter function (above), then\n          // the visitor must not have made any changes within this\n          // FragmentDefinition node. This fragment definition may still be\n          // removed if there are no ...spread references to it, but it won't be\n          // removed just because it has only a __typename field.\n          return node;\n        }\n\n        if ( // This logic applies only if the document contains one or more\n        // operations, since removing all fragments from a document containing\n        // only fragments makes the document useless.\n        operationCount > 0 && node.selectionSet.selections.every(function (selection) {\n          return selection.kind === Kind.FIELD && selection.name.value === \"__typename\";\n        })) {\n          // This is a somewhat opinionated choice: if a FragmentDefinition ends\n          // up having no fields other than __typename, we remove the whole\n          // fragment definition, and later prune ...spread references to it.\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    },\n    Directive: {\n      leave: function (node) {\n        // If a matching directive is found, remove the directive itself. Note\n        // that this does not remove the target (field, argument, etc) of the\n        // directive, but only the directive itself.\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    }\n  });\n\n  if (!firstVisitMadeChanges) {\n    // If our first pass did not change anything about the document, then there\n    // is no cleanup we need to do, and we can return the original doc.\n    return doc;\n  } // Utility for making sure inUse.transitiveVars is recursively populated.\n  // Because this logic assumes inUse.fragmentSpreads has been completely\n  // populated and inUse.removed has been set if appropriate,\n  // populateTransitiveVars must be called after that information has been\n  // collected by the first traversal of the document.\n\n\n  var populateTransitiveVars = function (inUse) {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach(function (childFragmentName) {\n          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function (varName) {\n            inUse.transitiveVars.add(varName);\n          });\n        });\n      }\n    }\n\n    return inUse;\n  }; // Since we've been keeping track of fragment spreads used by particular\n  // operations and fragment definitions, we now need to compute the set of all\n  // spreads used (transitively) by any operations in the document.\n\n\n  var allFragmentNamesUsed = new Set();\n  docWithoutDirectiveSubtrees.definitions.forEach(function (def) {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function (childFragmentName) {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (def.kind === Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment\n    // definitions count as usages of their own fragment names. This heuristic\n    // prevents accidentally removing all fragment definitions from the\n    // document just because it contains no operations that use the fragments.\n    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  }); // Now that we have added all fragment spreads used by operations to the\n  // allFragmentNamesUsed set, we can complete the set by transitively adding\n  // all fragment spreads used by those fragments, and so on.\n\n  allFragmentNamesUsed.forEach(function (fragmentName) {\n    // Once all the childFragmentName strings added here have been seen already,\n    // the top-level allFragmentNamesUsed.forEach loop will terminate.\n    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function (childFragmentName) {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n\n  var fragmentWillBeRemoved = function (fragmentName) {\n    return !!( // A fragment definition will be removed if there are no spreads that refer\n    // to it, or the fragment was explicitly removed because it had no fields\n    // other than __typename.\n    !allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);\n  };\n\n  var enterVisitor = {\n    enter: function (node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    }\n  };\n  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n    // If the fragment is going to be removed, then leaving any dangling\n    // FragmentSpread nodes with the same name would be a mistake.\n    FragmentSpread: enterVisitor,\n    // This is where the fragment definition is actually removed.\n    FragmentDefinition: enterVisitor,\n    OperationDefinition: {\n      leave: function (node) {\n        // Upon leaving each operation in the depth-first AST traversal, prune\n        // any variables that are declared by the operation but unused within.\n        if (node.variableDefinitions) {\n          var usedVariableNames_1 = populateTransitiveVars( // If an operation is anonymous, we use the empty string as its key.\n          getInUseByOperationName(node.name && node.name.value)).transitiveVars; // According to the GraphQL spec, all variables declared by an\n          // operation must either be used by that operation or used by some\n          // fragment included transitively into that operation:\n          // https://spec.graphql.org/draft/#sec-All-Variables-Used\n          //\n          // To stay on the right side of this validation rule, if/when we\n          // remove the last $var references from an operation or its fragments,\n          // we must also remove the corresponding $var declaration from the\n          // enclosing operation. This pruning applies only to operations and\n          // not fragment definitions, at the moment. Fragments may be able to\n          // declare variables eventually, but today they can only consume them.\n\n          if (usedVariableNames_1.size < node.variableDefinitions.length) {\n            return __assign(__assign({}, node), {\n              variableDefinitions: node.variableDefinitions.filter(function (varDef) {\n                return usedVariableNames_1.has(varDef.variable.name.value);\n              })\n            });\n          }\n        }\n      }\n    }\n  }));\n}\nexport var addTypenameToDocument = Object.assign(function (doc) {\n  return visit(doc, {\n    SelectionSet: {\n      enter: function (node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (parent && parent.kind === Kind.OPERATION_DEFINITION) {\n          return;\n        } // No changes if no selections.\n\n\n        var selections = node.selections;\n\n        if (!selections) {\n          return;\n        } // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n\n\n        var skip = selections.some(function (selection) {\n          return isField(selection) && (selection.name.value === \"__typename\" || selection.name.value.lastIndexOf(\"__\", 0) === 0);\n        });\n\n        if (skip) {\n          return;\n        } // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n\n\n        var field = parent;\n\n        if (isField(field) && field.directives && field.directives.some(function (d) {\n          return d.name.value === \"export\";\n        })) {\n          return;\n        } // Create and return a new SelectionSet with a __typename Field.\n\n\n        return __assign(__assign({}, node), {\n          selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false)\n        });\n      }\n    }\n  });\n}, {\n  added: function (field) {\n    return field === TYPENAME_FIELD;\n  }\n});\nvar connectionRemoveConfig = {\n  test: function (directive) {\n    var willRemove = directive.name.value === \"connection\";\n\n    if (willRemove) {\n      if (!directive.arguments || !directive.arguments.some(function (arg) {\n        return arg.name.value === \"key\";\n      })) {\n        globalThis.__DEV__ !== false && invariant.warn(98);\n      }\n    }\n\n    return willRemove;\n  }\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\n\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n\n  return !!selectionSet && selectionSet.selections && selectionSet.selections.some(function (selection) {\n    return hasDirectivesInSelection(directives, selection, nestedCheck);\n  });\n}\n\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);\n}\n\nfunction getArgumentMatcher(config) {\n  return function argumentMatcher(argument) {\n    return config.some(function (aConfig) {\n      return argument.value && argument.value.kind === Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));\n    });\n  };\n}\n\nexport function removeArgumentsFromDocument(config, doc) {\n  var argMatcher = getArgumentMatcher(config);\n  return nullIfDocIsEmpty(visit(doc, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          // Remove matching top level variables definitions.\n          variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function (varDef) {\n            return !config.some(function (arg) {\n              return arg.name === varDef.variable.name.value;\n            });\n          }) : []\n        });\n      }\n    },\n    Field: {\n      enter: function (node) {\n        // If `remove` is set to true for an argument, and an argument match\n        // is found for a field, remove the field as well.\n        var shouldRemoveField = config.some(function (argConfig) {\n          return argConfig.remove;\n        });\n\n        if (shouldRemoveField) {\n          var argMatchCount_1 = 0;\n\n          if (node.arguments) {\n            node.arguments.forEach(function (arg) {\n              if (argMatcher(arg)) {\n                argMatchCount_1 += 1;\n              }\n            });\n          }\n\n          if (argMatchCount_1 === 1) {\n            return null;\n          }\n        }\n      }\n    },\n    Argument: {\n      enter: function (node) {\n        // Remove all matching arguments.\n        if (argMatcher(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n  function enter(node) {\n    if (config.some(function (def) {\n      return def.name === node.name.value;\n    })) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(visit(doc, {\n    FragmentSpread: {\n      enter: enter\n    },\n    FragmentDefinition: {\n      enter: enter\n    }\n  }));\n} // If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\n\nexport function buildQueryFromSelectionSet(document) {\n  var definition = getMainDefinition(document);\n  var definitionOperation = definition.operation;\n\n  if (definitionOperation === \"query\") {\n    // Already a query, so return the existing document.\n    return document;\n  } // Build a new query using the selection set of the main operation.\n\n\n  var modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          operation: \"query\"\n        });\n      }\n    }\n  });\n  return modifiedDoc;\n} // Remove fields / selection sets that include an @client directive.\n\nexport function removeClientSetsFromDocument(document) {\n  checkDocument(document);\n  var modifiedDoc = removeDirectivesFromDocument([{\n    test: function (directive) {\n      return directive.name.value === \"client\";\n    },\n    remove: true\n  }], document);\n  return modifiedDoc;\n}\nexport function addNonReactiveToNamedFragments(document) {\n  checkDocument(document);\n  return visit(document, {\n    FragmentSpread: function (node) {\n      var _a; // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n      // since we want to react to changes in this fragment.\n\n\n      if ((_a = node.directives) === null || _a === void 0 ? void 0 : _a.some(function (directive) {\n        return directive.name.value === \"unmask\";\n      })) {\n        return;\n      }\n\n      return __assign(__assign({}, node), {\n        directives: __spreadArray(__spreadArray([], node.directives || [], true), [{\n          kind: Kind.DIRECTIVE,\n          name: {\n            kind: Kind.NAME,\n            value: \"nonreactive\"\n          }\n        }], false)\n      });\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["invariant","visit","Kind","checkDocument","getOperationDefinition","getFragmentDefinition","getFragmentDefinitions","getMainDefinition","isField","createFragmentMap","isArray","isNonEmptyArray","TYPENAME_FIELD","kind","FIELD","name","NAME","value","isEmpty","op","fragmentMap","selectionSet","selections","every","selection","FRAGMENT_SPREAD","nullIfDocIsEmpty","doc","getDirectiveMatcher","configs","names","Map","tests","forEach","directive","set","test","config","get","size","testConfig","makeInUseGetterFunction","defaultKey","map","inUseGetterFunction","key","inUse","variables","Set","fragmentSpreads","removeDirectivesFromDocument","directives","getInUseByOperationName","getInUseByFragmentName","getInUse","ancestors","p","ancestor","length","OPERATION_DEFINITION","FRAGMENT_DEFINITION","globalThis","operationCount","i","definitions","directiveMatcher","shouldRemoveField","nodeDirectives","some","remove","originalFragmentDefsByPath","firstVisitMadeChanges","fieldOrInlineFragmentVisitor","enter","node","docWithoutDirectiveSubtrees","Field","InlineFragment","VariableDefinition","Variable","_key","_parent","_path","add","FragmentSpread","FragmentDefinition","path","JSON","stringify","leave","originalNode","removed","Directive","populateTransitiveVars","transitiveVars","childFragmentName","varName","allFragmentNamesUsed","def","fragmentName","fragmentWillBeRemoved","has","enterVisitor","OperationDefinition","variableDefinitions","usedVariableNames_1","filter","varDef","variable","addTypenameToDocument","Object","assign","SelectionSet","parent","skip","lastIndexOf","field","d","added","connectionRemoveConfig","willRemove","arguments","arg","hasDirectivesInSelectionSet","nestedCheck","hasDirectivesInSelection","getArgumentMatcher","argument","aConfig","argMatcher","__assign","argMatchCount_1","document","definition","definitionOperation","operation","modifiedDoc","_a"],"sources":["/media/rk/disk2/React/crwn-clothing-graphql/node_modules/@apollo/src/utilities/graphql/transform.ts"],"sourcesContent":["import { invariant } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  ASTNode,\n  ASTVisitFn,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { visit, Kind } from \"graphql\";\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport type { FragmentMap } from \"./fragments.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\n\n// https://github.com/graphql/graphql-js/blob/8d7c8fccf5a9846a50785de04abda58a7eb13fc0/src/language/visitor.ts#L20-L23\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode>;\n  readonly leave?: ASTVisitFn<TVisitedNode>;\n}\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig =\n  RemoveNodeConfig<FragmentDefinitionNode>;\nexport type RemoveVariableDefinitionConfig =\n  RemoveNodeConfig<VariableDefinitionNode>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: \"__typename\",\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap\n): boolean {\n  return (\n    !op ||\n    op.selectionSet.selections.every(\n      (selection) =>\n        selection.kind === Kind.FRAGMENT_SPREAD &&\n        isEmpty(fragmentMap[selection.name.value], fragmentMap)\n    )\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return (\n      isEmpty(\n        getOperationDefinition(doc) || getFragmentDefinition(doc),\n        createFragmentMap(getFragmentDefinitions(doc))\n      )\n    ) ?\n      null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  configs: (RemoveDirectiveConfig | GetDirectiveConfig)[]\n) {\n  const names = new Map<string, RemoveDirectiveConfig | GetDirectiveConfig>();\n\n  const tests = new Map<\n    (directive: DirectiveNode) => boolean,\n    RemoveDirectiveConfig | GetDirectiveConfig\n  >();\n\n  configs.forEach((directive) => {\n    if (directive) {\n      if (directive.name) {\n        names.set(directive.name, directive);\n      } else if (directive.test) {\n        tests.set(directive.test, directive);\n      }\n    }\n  });\n\n  return (directive: DirectiveNode) => {\n    let config = names.get(directive.name.value);\n    if (!config && tests.size) {\n      tests.forEach((testConfig, test) => {\n        if (test(directive)) {\n          config = testConfig;\n        }\n      });\n    }\n    return config;\n  };\n}\n\n// Helper interface and function used by removeDirectivesFromDocument to keep\n// track of variable references and fragments spreads found within a given\n// operation or fragment definition.\ninterface InternalInUseInfo {\n  variables: Set<string>;\n  fragmentSpreads: Set<string>;\n  // Set to true when we deliberately remove a fragment definition, so we can\n  // make sure also to remove dangling ...spreads that refer to it.\n  removed?: boolean;\n  // Populated by the populateTransitiveVars helper function below.\n  transitiveVars?: Set<string>;\n}\nfunction makeInUseGetterFunction<TKey>(defaultKey: TKey) {\n  const map = new Map<TKey, InternalInUseInfo>();\n\n  return function inUseGetterFunction(\n    key: TKey = defaultKey\n  ): InternalInUseInfo {\n    let inUse = map.get(key);\n    if (!inUse) {\n      map.set(\n        key,\n        (inUse = {\n          // Variable and fragment spread names used directly within this\n          // operation or fragment definition, as identified by key. These sets\n          // will be populated during the first traversal of the document in\n          // removeDirectivesFromDocument below.\n          variables: new Set(),\n          fragmentSpreads: new Set(),\n        })\n      );\n    }\n    return inUse;\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  checkDocument(doc);\n\n  // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n  // operations as if their names were \"\". Anonymous fragment definitions are\n  // not supposed to be possible, but the same default naming strategy seems\n  // appropriate for that case as well.\n  const getInUseByOperationName = makeInUseGetterFunction<string>(\"\");\n  const getInUseByFragmentName = makeInUseGetterFunction<string>(\"\");\n  const getInUse = (\n    ancestors: readonly (ASTNode | readonly ASTNode[])[]\n  ): InternalInUseInfo | null => {\n    for (\n      let p = 0, ancestor: ASTNode | readonly ASTNode[];\n      p < ancestors.length && (ancestor = ancestors[p]);\n      ++p\n    ) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        // If an operation is anonymous, we use the empty string as its key.\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    invariant.error(`Could not find operation or fragment`);\n    return null;\n  };\n\n  let operationCount = 0;\n  for (let i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const shouldRemoveField = (nodeDirectives: FieldNode[\"directives\"]) =>\n    isNonEmptyArray(nodeDirectives) &&\n    nodeDirectives\n      .map(directiveMatcher)\n      .some(\n        (config: RemoveDirectiveConfig | undefined) => config && config.remove\n      );\n\n  const originalFragmentDefsByPath = new Map<string, FragmentDefinitionNode>();\n\n  // Any time the first traversal of the document below makes a change like\n  // removing a fragment (by returning null), this variable should be set to\n  // true. Once it becomes true, it should never be set to false again. If this\n  // variable remains false throughout the traversal, then we can return the\n  // original doc immediately without any modifications.\n  let firstVisitMadeChanges = false;\n\n  const fieldOrInlineFragmentVisitor: EnterLeaveVisitor<\n    FieldNode | InlineFragmentNode\n  > = {\n    enter(node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    },\n  };\n\n  const docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n\n    VariableDefinition: {\n      enter() {\n        // VariableDefinition nodes do not count as variables in use, though\n        // they do contain Variable nodes that might be visited below. To avoid\n        // counting variable declarations as usages, we skip visiting the\n        // contents of this VariableDefinition node by returning false.\n        return false;\n      },\n    },\n\n    Variable: {\n      enter(node, _key, _parent, _path, ancestors) {\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      },\n    },\n\n    FragmentSpread: {\n      enter(node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n        // We might like to remove this FragmentSpread by returning null here if\n        // the corresponding FragmentDefinition node is also going to be removed\n        // by the logic below, but we can't control the relative order of those\n        // events, so we have to postpone the removal of dangling FragmentSpread\n        // nodes until after the current visit of the document has finished.\n      },\n    },\n\n    FragmentDefinition: {\n      enter(node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave(node, _key, _parent, path) {\n        const originalNode = originalFragmentDefsByPath.get(\n          JSON.stringify(path)\n        );\n        if (node === originalNode) {\n          // If the FragmentNode received by this leave function is identical to\n          // the one received by the corresponding enter function (above), then\n          // the visitor must not have made any changes within this\n          // FragmentDefinition node. This fragment definition may still be\n          // removed if there are no ...spread references to it, but it won't be\n          // removed just because it has only a __typename field.\n          return node;\n        }\n\n        if (\n          // This logic applies only if the document contains one or more\n          // operations, since removing all fragments from a document containing\n          // only fragments makes the document useless.\n          operationCount > 0 &&\n          node.selectionSet.selections.every(\n            (selection) =>\n              selection.kind === Kind.FIELD &&\n              selection.name.value === \"__typename\"\n          )\n        ) {\n          // This is a somewhat opinionated choice: if a FragmentDefinition ends\n          // up having no fields other than __typename, we remove the whole\n          // fragment definition, and later prune ...spread references to it.\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n\n    Directive: {\n      leave(node) {\n        // If a matching directive is found, remove the directive itself. Note\n        // that this does not remove the target (field, argument, etc) of the\n        // directive, but only the directive itself.\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n  });\n\n  if (!firstVisitMadeChanges) {\n    // If our first pass did not change anything about the document, then there\n    // is no cleanup we need to do, and we can return the original doc.\n    return doc;\n  }\n\n  // Utility for making sure inUse.transitiveVars is recursively populated.\n  // Because this logic assumes inUse.fragmentSpreads has been completely\n  // populated and inUse.removed has been set if appropriate,\n  // populateTransitiveVars must be called after that information has been\n  // collected by the first traversal of the document.\n  const populateTransitiveVars = (inUse: InternalInUseInfo) => {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach((childFragmentName) => {\n          populateTransitiveVars(\n            getInUseByFragmentName(childFragmentName)\n          ).transitiveVars!.forEach((varName) => {\n            inUse.transitiveVars!.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n\n  // Since we've been keeping track of fragment spreads used by particular\n  // operations and fragment definitions, we now need to compute the set of all\n  // spreads used (transitively) by any operations in the document.\n  const allFragmentNamesUsed = new Set<string>();\n  docWithoutDirectiveSubtrees.definitions.forEach((def) => {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(\n        getInUseByOperationName(def.name && def.name.value)\n      ).fragmentSpreads.forEach((childFragmentName) => {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (\n      def.kind === Kind.FRAGMENT_DEFINITION &&\n      // If there are no operations in the document, then all fragment\n      // definitions count as usages of their own fragment names. This heuristic\n      // prevents accidentally removing all fragment definitions from the\n      // document just because it contains no operations that use the fragments.\n      operationCount === 0 &&\n      !getInUseByFragmentName(def.name.value).removed\n    ) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  // Now that we have added all fragment spreads used by operations to the\n  // allFragmentNamesUsed set, we can complete the set by transitively adding\n  // all fragment spreads used by those fragments, and so on.\n  allFragmentNamesUsed.forEach((fragmentName) => {\n    // Once all the childFragmentName strings added here have been seen already,\n    // the top-level allFragmentNamesUsed.forEach loop will terminate.\n    populateTransitiveVars(\n      getInUseByFragmentName(fragmentName)\n    ).fragmentSpreads.forEach((childFragmentName) => {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n\n  const fragmentWillBeRemoved = (fragmentName: string) =>\n    !!(\n      // A fragment definition will be removed if there are no spreads that refer\n      // to it, or the fragment was explicitly removed because it had no fields\n      // other than __typename.\n      (\n        !allFragmentNamesUsed.has(fragmentName) ||\n        getInUseByFragmentName(fragmentName).removed\n      )\n    );\n\n  const enterVisitor: EnterLeaveVisitor<\n    FragmentSpreadNode | FragmentDefinitionNode\n  > = {\n    enter(node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    },\n  };\n\n  return nullIfDocIsEmpty(\n    visit(docWithoutDirectiveSubtrees, {\n      // If the fragment is going to be removed, then leaving any dangling\n      // FragmentSpread nodes with the same name would be a mistake.\n      FragmentSpread: enterVisitor,\n\n      // This is where the fragment definition is actually removed.\n      FragmentDefinition: enterVisitor,\n\n      OperationDefinition: {\n        leave(node) {\n          // Upon leaving each operation in the depth-first AST traversal, prune\n          // any variables that are declared by the operation but unused within.\n          if (node.variableDefinitions) {\n            const usedVariableNames = populateTransitiveVars(\n              // If an operation is anonymous, we use the empty string as its key.\n              getInUseByOperationName(node.name && node.name.value)\n            ).transitiveVars!;\n\n            // According to the GraphQL spec, all variables declared by an\n            // operation must either be used by that operation or used by some\n            // fragment included transitively into that operation:\n            // https://spec.graphql.org/draft/#sec-All-Variables-Used\n            //\n            // To stay on the right side of this validation rule, if/when we\n            // remove the last $var references from an operation or its fragments,\n            // we must also remove the corresponding $var declaration from the\n            // enclosing operation. This pruning applies only to operations and\n            // not fragment definitions, at the moment. Fragments may be able to\n            // declare variables eventually, but today they can only consume them.\n            if (usedVariableNames.size < node.variableDefinitions.length) {\n              return {\n                ...node,\n                variableDefinitions: node.variableDefinitions.filter((varDef) =>\n                  usedVariableNames.has(varDef.variable.name.value)\n                ),\n              };\n            }\n          }\n        },\n      },\n    })\n  );\n}\n\nexport const addTypenameToDocument = Object.assign(\n  function <TNode extends ASTNode>(doc: TNode): TNode {\n    return visit(doc, {\n      SelectionSet: {\n        enter(node, _key, parent) {\n          // Don't add __typename to OperationDefinitions.\n          if (\n            parent &&\n            (parent as OperationDefinitionNode).kind ===\n              Kind.OPERATION_DEFINITION\n          ) {\n            return;\n          }\n\n          // No changes if no selections.\n          const { selections } = node;\n          if (!selections) {\n            return;\n          }\n\n          // If selections already have a __typename, or are part of an\n          // introspection query, do nothing.\n          const skip = selections.some((selection) => {\n            return (\n              isField(selection) &&\n              (selection.name.value === \"__typename\" ||\n                selection.name.value.lastIndexOf(\"__\", 0) === 0)\n            );\n          });\n          if (skip) {\n            return;\n          }\n\n          // If this SelectionSet is @export-ed as an input variable, it should\n          // not have a __typename field (see issue #4691).\n          const field = parent as FieldNode;\n          if (\n            isField(field) &&\n            field.directives &&\n            field.directives.some((d) => d.name.value === \"export\")\n          ) {\n            return;\n          }\n\n          // Create and return a new SelectionSet with a __typename Field.\n          return {\n            ...node,\n            selections: [...selections, TYPENAME_FIELD],\n          };\n        },\n      },\n    });\n  },\n  {\n    added(field: FieldNode): boolean {\n      return field === TYPENAME_FIELD;\n    },\n  }\n);\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === \"connection\";\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some((arg) => arg.name.value === \"key\")\n      ) {\n        invariant.warn(\n          \"Removing an @connection directive even though it does not have a key. \" +\n            \"You may want to use the key parameter to specify a store key.\"\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc)\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some((selection) =>\n      hasDirectivesInSelection(directives, selection, nestedCheck)\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === Kind.VARIABLE &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument)))\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions:\n              node.variableDefinitions ?\n                node.variableDefinitions.filter(\n                  (varDef) =>\n                    !config.some(\n                      (arg) => arg.name === varDef.variable.name.value\n                    )\n                )\n              : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(\n            (argConfig) => argConfig.remove\n          );\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach((arg) => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    })\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode\n  ): null | void {\n    if (config.some((def) => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    })\n  );\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === \"query\") {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: \"query\",\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === \"client\",\n        remove: true,\n      },\n    ],\n    document\n  );\n\n  return modifiedDoc;\n}\n\nexport function addNonReactiveToNamedFragments(document: DocumentNode) {\n  checkDocument(document);\n\n  return visit(document, {\n    FragmentSpread: (node) => {\n      // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n      // since we want to react to changes in this fragment.\n      if (\n        node.directives?.some((directive) => directive.name.value === \"unmask\")\n      ) {\n        return;\n      }\n\n      return {\n        ...node,\n        directives: [\n          ...(node.directives || []),\n          {\n            kind: Kind.DIRECTIVE,\n            name: { kind: Kind.NAME, value: \"nonreactive\" },\n          } satisfies DirectiveNode,\n        ],\n      };\n    },\n  });\n}\n"]},"metadata":{},"sourceType":"module"}